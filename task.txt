

Postgres password - root2151

UAN password - DJ@TechM748711




Prompt engineering course - https://learn.deeplearning.ai/chatgpt-prompt-eng/lesson/2/guidelines

open ai api key - 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


Zlib password - Zlib@098


http://loginzlib2vrak5zzpcocc3ouizykn6k5qecgj2tzlnab5wcbqhembyd.onion/

http://loginzlib2vrak5zzpcocc3ouizykn6k5qecgj2tzlnab5wcbqhembyd.onion/

https://go-to-zlibrary.se/#useful_link_tab

learn for learn not for the sake of doing it. have fun while reading or learning.

when you are passionate about something it does not seem like much of the trouble. 

self study - list down the topics. and google about it.

make projects.

do not try to be an expert.

dsa every morning

MLH
Github campus expert
civo academy -- to learn kubernetes - https://www.civo.com/academy
CNCF - cloud native computing founddation. 
https://www.twitch.tv/cloudnativefdn
https://kubernetes.io/
https://dok.community/


-refactor notes make it concise

-Spring in action

spring boot scaler course - https://www.scaler.com/topics/course/java-spring-boot-blogging-app/ 


---------

1) DeConstruct the skill - divide the skill into smaller and more granular skills.

Most skills are big bundle of different skills. 

2) Learn enough to self-correct - get 3 to 5 resources about the skill you want to learn.

at the start learn just enough that you can actually parctice and self-correct.

get better to understand the mistakes and correct it.

3) Remove practice barriers - Distraction, TV.

4) practice at least 20 hours

The major barrier to skill acquisition isn't intellectual..... its emotional.

-----------------

Do not binge watch youtube.

-----------------------



mysql interview concepts - 


1.Select nth Highest salary without aggregate function
2.Delete duplicate data
3.Indexers(Cluster and Non-cluster) - done
4.Normalization - done
5.ACID property - done
6.Primary vs Unique key - done
7.Stored Procedure and Functions - done 
8.Joins(Self Join main) - 5 joins - inner, left, right, self and full.
9.CTE
10.VIEWS
11.UNION AND UNION ALL


-----------

Modify LLD notes and put it on the sheet.

-------------


Murugan about section on linked in -

Continue as a Technical Lead/Manager/Software Architect in challenging and state-of the art banking/financial software projects in areas of High frequency Trading, Portfolio construction and Multi Asset Market data with a progressive, innovative and revolutionary latest technologies such as a real time, near real time (A sync) implementation, multi-threading, web services integration, online database or cache interaction, and excellent debugging skills.


----



Implemented server-side components for venues of trading Module for Morgan Stanley equity, MF, ETF Trading Systems using above mentioned environment 
 Serving data in/out with APACHE Ignite for Low latency services.
 Migrate applications Async transactions move from MQ to KAFKA Streams to achieve low latency data availability throughout application (Drift Calculation & sending trade to market).
 Built a Ticker Plant with core Java over TREP (Thomson Reuters Enterprise Platform) real time market data feeds with better performance in design.
 Built and guided others in building STP interfaces to connect Bloomberg and IPREO using FIX 4.3. Included special handing of amends and cancels. 
 Utilized SOAP && REST web services API (Micro service using API gateway) to Various internal and external applications from MS environments.
 Helped deliver development and testing work using Java Spring, Morgan Stanley internal stack using internal continuous delivery environment called Train.
 Developed stress test for high volume trade booking system.
 Working with global teams to delivered team goals. Including bringing new resources up to speed in Morgan Stanley Technologies and management communications.
 Managed release meetings for client on boarding.
 Optimized for better performance, debugged and fixed multiple existing production problems.


-------------

HLD topics - 
System desing 101 and consistent hashing
caching 
cap theorem and Master slave
SQL vs NoSQL
NOSQL innternals 
case study - typeahead
case study - messaging, like facebook messanger.
Zookeeper + Kafka
case study - elastic search 
s3 + Quad trees ( nearest neighbors)
case study - design uber
popular interview questions
case study - hotstar

LLD -
OOP and LLD 101
SOLID principle
Creational design pattern
Structural design pattern
Behavioral design pattern and UML diagrams
How to approach design problems and design a pen.
Design tik tac toe
Desing snake and ladder
desing parking lot
design book my show
schema design
design spilwise

-----------

Job protals - 

Hirebeen
CutShort
Wellfound

Remote jobs - 

Mercer.com - schedule the interview
Micro1.ai - practice interview - voice interview.
Turing.com
Wellfound.com

-------------

DSA :- Applications of Knapsack

dp[2] - if we pick value 3 

---------
React JS - 


Dynamic routing - 

now we are configuring the routes so that it will return header and footer components with about and contact page.

1) make all the routes like /, /about, /contact, the children routes of the / route.

const appRouter = createBrowserRouter([
  {
    path: "/",
    element: <AppLayout />,
    errorElement: <Error />,
    children: [
      {
        path: "/",
        element: <Body />,
      },
      {
        path: "/about",
        element: <About />,
      },
      {
        path: "/contact",
        element: <Contact />,
      },
    ],
  },
]);


2) update AppLayout to - 

const AppLayout = () => {
  return (
    <>
      <Header />
      <Outlet />
      <Footer />
    </>
  );
};

in above The Outlet component in react-router-dom is a special component that allows you to render child routes within its scope. It is particularly useful when you want to nest routes in a layout component and render the nested components based on the route configuration.

now if we visit the home page it will render the home page with header and footer , and if we render the about page then it will render about page with header and footer components same is true for contact component.

code -

index.js - 

import React from "react";
import { createRoot } from "react-dom/client";
import Header from "./components/Header";
import Footer from "./components/Footer";
import Body from "./components/Body";
import { createBrowserRouter, RouterProvider, Outlet } from "react-router-dom";
import About from "./components/About";
import Error from "./components/Error";
import Contact from "./components/Contact";

const AppLayout = () => {
  return (
    <>
      <Header />
      <Outlet />
      <Footer />
    </>
  );
};

const appRouter = createBrowserRouter([
  {
    path: "/",
    element: <AppLayout />,
    errorElement: <Error />,
    children: [
      {
        path: "/",
        element: <Body />,
      },
      {
        path: "/about",
        element: <About />,
      },
      {
        path: "/contact",
        element: <Contact />,
      },
    ],
  },
]);

const root = createRoot(document.getElementById("root"));

root.render(<RouterProvider router={appRouter} />);

in above <Outlet /> component is replayed by Body or About or Contact component according to the url path while rendering the header and footer correctly.

01:53:21

---------------

React follows unidirectional data flow - 

it is also known as one-way binding. It means that data in react applicatiion flows in a single direction, from parent components to child components. This helps to maintain a predictable state and makes it easier to debug and understand the application.

React Hooks - these are the features that allow developers to use state and other react features in functional components, instead of relying on class components. Hooks provide a simpler and more concise way of managing state and lifecycle events.

I has many different libraries like React router, redux for state management and Axios for making API requests.

React JS environement setup - 

Install NVM - Instead of using npm to install and uninstall Node versions for your different projects, you can use nvm, which helps you effectively manage your node versions for each project.

https://www.freecodecamp.org/news/node-version-manager-nvm-install-guide/

commands - 

nvm list - it lists different versions of the currently installed node js.

nvm install <VERSION_NO>  - to install new version

nvm use <VERSION_NO> - to use provided version of node js. this command is used to switch between different versions of the node js.


Install Node JS.

then reinstall npm globally - 

npm install -g npm


create react app - 

npx create-react-app project1

this will create react app with the name project1.

video 4 - 03:58

------------



IP 
20.235.204.218

user dssdevelop9


pwd - DssCodee#91!


-------------


Servlets and JSP  - 

In Java, the RequestDispatcher is an interface provided by the Servlet API to forward the request from one servlet to another or include the response from another resource (servlet, JSP, or HTML file) in the response. To create an object of RequestDispatcher, you typically obtain it from the ServletContext or ServletRequest object.

Here's an example of how you can create an object of RequestDispatcher:

forward method - 

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/MyServlet")
public class MyServlet extends HttpServlet {

    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        // Get the RequestDispatcher from ServletContext
        RequestDispatcher dispatcher = getServletContext().getRequestDispatcher("/anotherServlet"); // here we have to give servlet url pattern

        // Forward the request to anotherServlet
        dispatcher.forward(request, response);
    }
}



In Java, the RequestDispatcher is an interface provided by the Servlet API to forward the request from one servlet to another or include the response from another resource (servlet, JSP, or HTML file) in the response. To create an object of RequestDispatcher, you typically obtain it from the ServletContext or ServletRequest object.

Here's an example of how you can create an object of RequestDispatcher:

java
Copy code
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/MyServlet")
public class MyServlet extends HttpServlet {

    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        // Get the RequestDispatcher from ServletContext
        RequestDispatcher dispatcher = getServletContext().getRequestDispatcher("/anotherServlet");

        // Forward the request to anotherServlet
        dispatcher.forward(request, response);
    }
}
In this example, getServletContext().getRequestDispatcher("/anotherServlet") is used to obtain a RequestDispatcher object for the servlet or resource with the mapping "/anotherServlet". You can also use getRequestDispatcher method of HttpServletRequest if you want to dispatch the request to a resource within the same web application.

Remember to replace "/anotherServlet" with the appropriate path to the resource you want to forward the request to.

include() method - 

In Java, the RequestDispatcher interface is typically used to forward or include the request and response objects between servlets or between a servlet and a JSP page. To create an object of RequestDispatcher for the include method, you generally use the getRequestDispatcher method available in the ServletContext or ServletRequest interface.

Here's an example of how you can create a RequestDispatcher object for the include method:

java
Copy code
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/IncludeExampleServlet")
public class IncludeExampleServlet extends HttpServlet {

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // Get the RequestDispatcher from ServletContext
        RequestDispatcher dispatcher = getServletContext().getRequestDispatcher("/path/to/your/included/page.jsp");

        // Include the content of the specified resource (in this case, a JSP page)
        dispatcher.include(request, response);
    }
}
In this example:

The getServletContext().getRequestDispatcher("/path/to/your/included/page.jsp") method is used to obtain a RequestDispatcher object. Replace "/path/to/your/included/page.jsp" with the actual path to the resource you want to include.

The dispatcher.include(request, response) method is then called to include the content of the specified resource in the current response.

Make sure to replace the placeholder path with the actual path to the resource you want to include. Additionally, handle exceptions appropriately based on your application's error-handling strategy.

--------------

Aman kumar - kumar.aman@scaler.com
optimizing linkedin profile and resume - https://www.youtube.com/watch?v=d3Immi3OGOE&t=1017s


===================

JSP - 

JSP is an HTML page with some java code sprinkled in and includes dynamic content from java code.

JSP file is processed on server. Result of the java code included in HTML returned to browser.

JSP file goes into WebContent or webapp folder and it must have a .jsp extension.


create file called hello.jsp in webapp folder of the dynamic web project. 

hello.jsp - 

<html> 
<body>

<h3> Hello world of java </h3>

the time is <%= new java.util.Date() %>
</body>
</html>

JSP scripting elements - 

JSP expression - <%= some java expression %>

JSP Scriptlet - <% some java code 1 to many lines %>

JSP declaration - <%! variable or method declaration %>


1) JSP expression - used to compute an expression and result of the expression is included in HTML and returned to the browser. 

<%= some java expression %>

<h2> the time is <%= new java.util.Date() %> </h2>

<%= new String("Hello world").toUpperCase() %>  // hello world

<%= 25 * 4 %> // 100

<%= 75 < 69 %>  // false


jsp expression examples - 

In JavaServer Pages (JSP), expressions are used to insert dynamic content into the HTML page. They are enclosed within `<%=` and %> tags. Here are different examples of JSP expressions:

1. Displaying a Variable:
   
   <p>Welcome, <%= username %></p>
   
   In this example, the value of the username` variable will be displayed in the HTML page.

2. Mathematical Expression:
   
   <p>Result: <%= 10 + 5 %></p>
   
   The result of the mathematical expression `10 + 5` will be displayed.

3. Concatenating Strings:
   
   <p><%= "Hello, " + username %></p>
   ```
   Concatenating a string with the value of the `username` variable.

4. **Using Method Call:**
   ```jsp
   <p>Length of the string: <%= inputString.length() %></p>
   ```
   Invoking the `length()` method on the `inputString` variable.

5. **Conditional Expression:**
   ```jsp
   <p>
      <% if (isUserLoggedIn) { %>
         Welcome back!
      <% } else { %>
         Please log in.
      <% } %>
   </p>
   ```
   Displaying different messages based on the value of the `isUserLoggedIn` variable.

6. **Accessing Elements in an Array:**
   ```jsp
   <p>First element: <%= myArray[0] %></p>
   ```
   Accessing the first element in the `myArray` array.

7. **Accessing Properties of an Object:**
   ```jsp
   <p>User email: <%= user.getEmail() %></p>
   ```
   Accessing the `email` property of the `user` object.

8. **Using JSP Expression Language (EL):**
   ```jsp
   <p>Total cost: ${totalCost}</p>
   ```
   JSP EL simplifies expressions. The `${}` syntax is used to directly access the `totalCost` variable without using `<%= %>`.

Remember that JSP expressions are evaluated at the server-side before the HTML page is sent to the client. They provide a way to embed dynamic content within static HTML pages.


JSP scriplets - 

<% 

for( int i =1; i <= 5; i++){
out.println("<br/> I really luv2code: " + i);
}

%>

output of above will look like below - 


this is printing line in jsp page0
this is printing line in jsp page1
this is printing line in jsp page2
this is printing line in jsp page3
this is printing line in jsp page4

best practice in JSP scriptlets - minimize the amount of scriptlet code in a jsp and avoid dumping thousands of lines of code in jsp.

Declaring and Initializing Variables:

jsp
Copy code
<% 
   int x = 10;
   String message = "Hello, JSP!";
%>
Looping through a Range of Numbers:

jsp
Copy code
<%
   for (int i = 1; i <= 5; i++) {
       out.println("Count: " + i + "<br>");
   }
%>
Conditional Statements:

jsp
Copy code
<%
   int temperature = 25;
   if (temperature > 20) {
      out.println("It's a warm day!");
   } else {
      out.println("It's a cool day.");
   }
%>
Accessing Request Parameters:

jsp
Copy code
<%
   String username = request.getParameter("username");
   out.println("Hello, " + username + "!");
%>
Using JavaBeans:

jsp
Copy code
<%
   // Assuming there's a JavaBean named "user" with a getName() method
   UserBean user = (UserBean) request.getAttribute("user");
   out.println("User Name: " + user.getName());
%>
Exception Handling:

jsp
Copy code
<%
   try {
      // Some code that might throw an exception
      int result = 10 / 0;
      out.println("Result: " + result);
   } catch (ArithmeticException e) {
      out.println("Error: Division by zero");
   }
%>
Including HTML within Scriptlets:

jsp
Copy code
<% 
   for (int i = 0; i < 3; i++) {
%>
   <p>This is paragraph <%= i + 1 %></p>
<%
   }
%>
Using External Java Classes:

jsp
Copy code
<%
   // Importing an external Java class
   import com.example.UtilityClass;

   // Using a method from the external class
   out.println("Result: " + UtilityClass.calculate());
%>


JSP declarations - 

it is used to declare a method in the jsp page. and call the same method in the same jsp page.

<%!
// declare a method 

%>


<%! String makeItLower( String data ) {

return data.toLowerCase();
}

%>

calling method in java  - 

Lower case "Hello World" : <%= makeItLower("Hello World") %>

best practice - 

Minimize the no of declarations in a JSP.
avoid dumping thousands of lines of code in a JSP.
Refactor this into a separate classes and make use of MVC.

JSP declarations are used to declare variables and methods that can be used later in the JSP page. Declarations are written between `<%!` and `%>` tags. Here are some examples of JSP declarations:

1. **Variable Declaration:**
   ```jsp
   <%!
      int counter = 0;
   %>
   ```
   This declares an integer variable `counter` with an initial value of 0.

2. **Method Declaration:**
   ```jsp
   <%!
      public String welcomeMessage() {
         return "Hello, JSP!";
      }
   %>
   ```
   This declares a method `welcomeMessage` that returns a greeting message.

3. **Initializing Variables:**
   ```jsp
   <%!
      String username = "Guest";
   %>
   ```
   This declares and initializes a String variable `username` with the value "Guest".

4. **Importing Java Packages:**
   ```jsp
   <%!
      import java.util.ArrayList;
   %>
   ```
   This declares the import of the `ArrayList` class from the `java.util` package.

5. **Using JavaBeans:**
   ```jsp
   <%!
      private UserBean user;
   %>
   ```
   This declares a private variable `user` of type `UserBean`, assuming there is a JavaBean class named `UserBean`.

6. **Constants Declaration:**
   ```jsp
   <%!
      final int MAX_SIZE = 100;
   %>
   ```
   This declares a constant variable `MAX_SIZE` with a value of 100.

7. **Combining Declarations:**
   ```jsp
   <%!
      int counter = 0;
      String greeting = "Hello, JSP!";
   %>
   ```
   This combines the declaration of an integer variable `counter` and a String variable `greeting`.

8. **Method with Parameters:**
   ```jsp
   <%!
      public int multiply(int a, int b) {
         return a * b;
      }
   %>
   ```
   This declares a method `multiply` that takes two parameters and returns their product.

Remember that JSP declarations are typically used for variable and method declarations, providing a way to encapsulate logic within a JSP page. However, it's generally recommended to use JavaBeans or other Java classes for more complex logic to keep the JSP code clean and maintainable.

Certainly! After declaring variables and methods in JSP declarations, you can use them in various parts of your JSP page. Here are examples of calling the previously declared variables and methods:

1. **Using a Declared Variable:**
   ```jsp
   <%!
      int counter = 0;
   %>
   
   <%
      // Using the declared variable
      counter++;
      out.println("Counter: " + counter);
   %>
   ```

2. **Calling a Declared Method:**
   ```jsp
   <%!
      public String welcomeMessage() {
         return "Hello, JSP!";
      }
   %>
   
   <%
      // Calling the declared method
      String message = welcomeMessage();
      out.println("Message: " + message);
   %>
   ```

3. **Accessing Initialized Variables:**
   ```jsp
   <%!
      String username = "Guest";
   %>
   
   <%
      // Accessing the initialized variable
      out.println("Welcome, " + username);
   %>
   ```

4. **Using Imported Java Packages:**
   ```jsp
   <%!
      import java.util.ArrayList;
   %>
   
   <%
      // Using the imported class
      ArrayList<String> myList = new ArrayList<>();
      myList.add("Item 1");
      myList.add("Item 2");
      out.println("List: " + myList);
   %>
   ```

5. **Accessing JavaBeans:**
   ```jsp
   <%!
      private UserBean user;
   %>
   
   <%
      // Accessing the JavaBean
      if (user != null) {
         out.println("User Name: " + user.getName());
      }
   %>
   ```

6. **Using Constants:**
   ```jsp
   <%!
      final int MAX_SIZE = 100;
   %>
   
   <%
      // Using the constant
      out.println("Maximum Size: " + MAX_SIZE);
   %>
   ```

7. **Calling a Method with Parameters:**
   ```jsp
   <%!
      public int multiply(int a, int b) {
         return a * b;
      }
   %>
   
   <%
      // Calling the method with parameters
      int result = multiply(5, 3);
      out.println("Result: " + result);
   %>
   ```

These examples demonstrate how to use the declared variables and methods within the JSP page. It's important to note that JSP declarations provide a way to encapsulate reusable logic within the page, making it more modular and maintainable.

Call java class from JSP - 

in jsp we can call java classes. 

1) create java class.
2) Call java class from jsp file.

	

calling java class methods by using fully qualified class names - 

<%= com.jspmania.FunUtils.getName("Mhais")
%>

calling java methods by importing the class - 

<%@page import="com.jspmania.FunUtils"%>
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>First page</title>
</head>
<body>
<h5>  time right now is <%= new java.util.Date() %></h5>

<%= FunUtils.getName("thats what you are earning")
%>
</body>
</html>

in above we are importing the java class by using below line 

<%@page import="com.jspmania.FunUtils"%>

In JavaServer Pages (JSP), you can call Java classes by using Java expressions, scriptlets, or custom tags. Here are examples of each:

1. **Java Expression:**
   You can use Java expressions directly within your JSP to call methods from a Java class.

```jsp
<%@ page import="com.example.MyClass" %>

<%
   String result = MyClass.myMethod(); // Assuming myMethod is a static method
   out.println("Result: " + result);
%>
```

2. **Scriptlet:**
   Scriptlets allow you to embed Java code directly within your JSP.

```jsp
<%@ page import="com.example.MyClass" %>

<%
   MyClass myObject = new MyClass();
   String result = myObject.myMethod(); // Assuming myMethod is an instance method
   out.println("Result: " + result);
%>
```

3. **Custom Tags:**
   You can create custom tags to encapsulate Java code and make your JSP more modular.

Assuming you have a custom tag implementation (`MyCustomTag`) with a TLD file (`mytaglib.tld`):

```jsp
<%@ taglib uri="/WEB-INF/mytaglib.tld" prefix="mytag" %>

<mytag:myCustomTag/>
```

In the TLD file (`mytaglib.tld`):

```xml
<?xml version="1.0" encoding="UTF-8"?>
<taglib xmlns="http://java.sun.com/xml/ns/j2ee"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd"
        version="2.0">
    <tlib-version>1.0</tlib-version>
    <short-name>mytaglib</short-name>
    <uri>/WEB-INF/mytaglib.tld</uri>
    <tag>
        <name>myCustomTag</name>
        <tag-class>com.example.MyCustomTag</tag-class>
        <body-content>JSP</body-content>
    </tag>
</taglib>
```

In the custom tag class (`MyCustomTag`):

```java
package com.example;

import javax.servlet.jsp.tagext.TagSupport;
import javax.servlet.jsp.JspException;
import java.io.IOException;

public class MyCustomTag extends TagSupport {
    public int doStartTag() throws JspException {
        try {
            MyClass myObject = new MyClass();
            String result = myObject.myMethod(); // Assuming myMethod is an instance method
            pageContext.getOut().println("Result: " + result);
        } catch (IOException e) {
            throw new JspException(e.getMessage());
        }
        return SKIP_BODY;
    }
}
```

Make sure to adjust the package and class names according to your project structure and requirements.


Built-in server objects - 

there are some objects which are automatically available to use no need to import in jsp page.

List of commaonly used objects - 

request - contain HTTP request header and form data.
response - provides HTTP support for sed=nding the response.
out - JspWriter for including content in html page.
session - unique session for each user of the web application.
application - shared data for all users  of the web application.


<h5> <%= request.getHeader("User-Agent") %></h5>
<h5> <%= request.getLocale() %></h5>

In JavaServer Pages (JSP), there are several built-in objects that provide access to various functionalities and information during the processing of a JSP page. Here are examples of some commonly used built-in objects:

1. **request:**
   The `request` object represents the client's request to the server. It is an instance of the `HttpServletRequest` class.

```jsp
<p>Client's IP Address: <%= request.getRemoteAddr() %></p>
<p>User Agent: <%= request.getHeader("User-Agent") %></p>
```

2. **response:**
   The `response` object is used to send content back to the client. It is an instance of the `HttpServletResponse` class.

```jsp
<%
   response.setContentType("text/html");
   response.getWriter().println("<h1>Hello, World!</h1>");
%>
```

3. **out:**
   The `out` object is a PrintWriter that allows you to send content to the client.

```jsp
<%
   out.println("This is printed to the client's browser.");
%>
```

4. **session:**
   The `session` object represents the user's session and is an instance of the `HttpSession` class.

```jsp
<%
   session.setAttribute("username", "john_doe");
   out.println("Username: " + session.getAttribute("username"));
%>
```

5. **application:**
   The `application` object represents the entire web application and is an instance of the `ServletContext` class.

```jsp
<%
   application.setAttribute("appVariable", "This is a global variable");
   out.println("Global Variable: " + application.getAttribute("appVariable"));
%>
```

6. **config:**
   The `config` object provides access to the configuration information of the current JSP page and is an instance of the `ServletConfig` class.

```jsp
<%
   String servletName = config.getServletName();
   out.println("Servlet Name: " + servletName);
%>
```

These built-in objects provide a convenient way to interact with various aspects of the JSP environment, HTTP request, and application context.


Including files with JSP - 

like we can include header and footer files in any file.

<jsp:include page="my-header.html" />
< jsp:include page="my-footer.jsp" /> 

create header and footer files and add them to the main file by using include, shown below - 

<body>

<jsp:include page="header.jsp" />


<h5> <%= request.getHeader("User-Agent") %></h5>
<h5> <%= request.getLocale() %></h5>

<jsp:include page="footer.jsp" />

</body>


HTML forms - 

HTML forms are used to get the data from the user.

---------------

nba issue - 

first we have to go and check the outstanding_amount, psm in samastt and exposure1 and exposure2 for both the clients in production data in date range 12-09-2023 to 14-09-2023.



the one has 5 rows is it of IGST 
and the one has 6 rows it is of SGST and CGST.


IGST if not in different state.
SGST_CGST if transaction is happening in different state.

IGST and CGST_SGST values are there in dam_approved_invoicerecord. 



Inter - IGST
Intra - CGST_SGST

if GST is true in front end then generate success fee- if that invoice has IGST in backend then return inter success fee. and if invoice has CGST_SGST in the backend then return intra success fee.

if it false then generate obligation.

payment method is hardcoded in sell obligation row.

if amount is null then store 0 as value.


===============

what does it mean to quantize a neural network - 

In this quantization bit are simulated for weight and for activation.

weight and activation can have different bit-precision to maintain accuracy. 

Simulated quantization ops are added in the neural network after each usage of weights and activations and after every operation.

Quantizationi is generally simulated in floating point instead of running in interger math.
Weights and activations can be quantized with the same or different precisions within a model layer.

for ex - W8A16 uses quantized 8 bit weights and 16-bit activations. INT8 means quantized 8bit weight and 16-bit activation.

Quantizaion noise can reduce model accuracy. 


AIMET work flow and post-training quantization - 

AIMET makes AI models small and easy to run on hardware. AIMET is open-sources github project that includes state of the art quantization and compression technique from qualcomm ai research.

we will give a trained tensorflow or PyTorch AI model as a input to the AIMET, It will compress and quantize the model and then return optimized AI model which will be deployed on any device like car, mobile or other platforms.

Advanages of AIMET - Lower power, Lower memory bandwidth, Maintains model accuracy, Higher performance, Simple ease of use.

features - 

Quantization - State of the art INT8 and INT4 performance. 
Post-training quantization (PQT) - 
Take pre-trained FP32 model and convert it directly into fixed point network.

pros - No need for the original training pipeline. Data free or small ( unlabeled) calibration set needed.
Simple usage ( single API call).

cons - Might not reach as high accuracy as QAT.

Quantization-aware training (QAT)- 
Train/fine tune the network with the simulated quantization operations in place.

pros - Achieves higher accuracy, especially for lower bit-widths.

cons - Required access to the training pipeline and labbelled data. Longer training times, Hyper-parameter tuning.

Advance data free, post training quantization ( PTQ) methods - AdaRound optimizes network weights in minutes without model fine-tuning on training data.

It also has two types - 
1) Baseline ( Nearest rounding) - this less accurate. in this floating points are rounded to the nearest int.
2) AdaRound - This is more accurate. 
Compression - Efficient tensor decomposition and removal of redundant channels in convolution layers, Spatial singular value decomposition, Channel prunning.

Visualization - analysis tools for drawing insights for quantization and compression, weight ranges, oer layer compression sensitivity.


as a part of AIMET qualcomm also provides AutoQuant which simplifies post-training quantization. It analyzes the model, applies best sequence of already existing post-training quantization features.
Returns the best accuracy model with analysis report. A simple, blackbox, push-button solution. 

advt of AIMET - it converts floating point 32 model and convert it into INT8 type and still has same accuracy as that of original one.

AIMET can also quantizes transformers with high accuracy, Comparable to FP32.

-------------------

Questions came across at AI interview - 

advantages of encapsulation in large code bases.

difference between default methods in interface and abstract class.

fields of the class are made private and method are made public in case of encapsulation the reason is principles of information hiding and protection of data.

--------

WebRTC - 

Web real time communication 
It is used to find peer to peer path to exchange video and audio in an efficient and low latency manner.
It enables rich communcations browsers, mobile, IOT devices.

-------------

top 100 product companies

first service based
then try for product based.

mornig update resume on naukri and update profile.


----------
 topics - 

1) Design patterns
2) Solid Principles
3) File Upload(Single and Multiple)
4) Video Upload as Data stream
5) Forms with validation, error handling and warning messages 
6) Ajax and xmlhttpRequest
7) Importing javascript and code Reusablility

-----


JS topics - 

oop in js with this keyword


---------
css - 

---------

schema design - 

nouns 

users 

profiles

videos

actors

columns of each tables - 

users 
user_id
email
password

profiles
profile_id
types - kid or adult

videos 
video_id
title
description

actors - 
actor_id
name

profile_type
id
value - kid or adult

relationship between the tables - 

user and profile has - one user has many profiles  so relation users and profile is 1:m 

so store the userid in the profile table

2) profile with profile_type - m:1
	so profile type id will be stored in profile table.

3) video and actor - m:m

so for this we nned to create new table to store the mapping with vidooid and actorid columns.

4) video and profile - m:m 

we need top create seperate mapping table for this 


videoId and profileId 

video_status
status_type_id 
value

video_profile - 

video_id
profile_id
video_status_id
timestamp


-------

nouns 

movie
movieId 
title
year
director_id


actor
actor_id
name


director
name
director_id

relations - 

1) Movie and director - 

m:1

so store the director_id in the movies table.

2) movie and actor - 

m:m 

we need seperate table to store this relation 

movie_id and actor_id

movie_actor - 
movie_id
actor_id

------------

nouns 

batches 

students - 
student_id
batch_id


classes/lectures - 
class_id
instructor_id
batch_id
timeline
created_by_instructor_id


problems - 
problem_id
problem_type - assignment or homework
created_by_instructor_id
modified_by_instructor_id

instructors
instructor_id
name

notes
notes_id
notes_type - lecture and pre-lecture

cardinality - 

1) student & batches - 
student can be part of only one batch at a time.

one student part of one batch and one batch can have many students so  relation between student and batch is - m:1

so we need to store batch_id in student table.

2) student & lecture - one student can have many lectures and one lecture can have many students so it is m:m relation. so create new table to store the relation between these two.

student_lecture - 
student_id
lecture_id

3) lecture has assignment and homework - one lecture has many problemss and one problem is belong to only one lecture. so this relation of lecture and problem is 1:m.

so store lecture_id in problems table.

4) assingment and homework has 0 to 10 problems - create problems table and storing the problem_id and problem description and problem_type like assingment or homework. 

problems - 
problem_id
description
problem_type_id

5) lectures and instructors - 

one lecture has one instructor and one instructor can be a part of many lectures, so this relation betwween lecture and instructor is - m:1. 

so store instructr_id in lecture table.

6) prelecture content and lecture notes - 

created one table for storign the all notes and its types. 

notes- 
notes_id
notes_type

7) lecture and notes - 

one lecture has many notes and one note can be a part of the one lecture. so this relation between lecture and notes is - 1:m 

so store lecture_id in the notes table. 

8) lecture and problems - one lecture has many problems and one problem can be part of only one lecture, so this relation between lecture and problem is 1:m - 

so store lecture_id in problems table. 

9) problems solved - student and problems - 

create separate table for solved problems which will store the student_id and problem_id 

solved_problems - 

student_id
problem_id

so relation between student and solved_problems is one student can solve many problems and one problem can solved by many student, so relation between student and solved_problems - m:m.

solved_problems - 

student_id
problem_id
problem_solving_status_id

problem_solving_status - 

problem_solving_status_id
value


10) class timeline - 

add timeline column to the lecture table. 

11) create separate table to store the attendance of the student for the lecture. one lecture is attended by many students and one student can attend many lectures so the relation between student lecture is m:m - 

so create separate table to store the this relation with below - 

attendance - 
lecture_id
student_id
attendance  - yes or no 

12) instructor will be able to see all the lectures taken by him we are storing instructor_id in the lecture table.

to make it efficient we can create index on lecture_id and instructor_id. 

13) 

--------
companies - 
company_id

connections - 
connetction_id
email
company_id

campaigns - 
campaign_id
company_id

email_template - 
template_id
template_type_id 

email_template_type
email_template_type_id
email_template_type -introductory mail, reminder mail


cardinality - 

1) each campaign can have multiple email templates - 

one compain can have multiple templates and one template can belong to multiple campaigns so it is M:M relation. 

create new table called 

campaign_template
campaign_id
template_id

2) campaign and connections relation - 

one campaign can have multiple connections and one connection can belong to multiple campaigns. 

so itst m:m relation and we need separate table to store this relation. 

campaign_connections
camapaign_id
connection_id
is_campaign_active

----

React JS - 

install node and npm.

create react app - 

npx create-react-app udemyclone

to run the react app - 

first cd to the folder and then enter below command.

npm start 

-------

project - 

12:48


cold bath
neem and turmeric at empty stomach with mildely laced honey warm water.
gurupooja
drink water stored in vessel, avoid travelling water let it settle for  5 hrs and then drink.
do meditation on sandhyakala - 20 before and after sunrise and midday and sunset and midnight.
crash course

to deepen the experince - 
do hatha yoga 
devotion
be aware be living being not thinking being.

fast on ekadasi

first be
then do 
then u will have it
---------



check infix string from left to right and if char is operand then concat it to the ans and if char is operand then  check the precedence of the char at the top of the stack if current operand has higher precedence then just push the operand to the stack and if operand has lower precedence than the top stack element then remove all the elements from the stack and add to the ans. 

--------

Building an Android app for the agriculture market is a fantastic initiative! To ensure maximum interaction from farmers, consider incorporating the following features:

1. **Crop Information and Recommendations**:
   - Provide detailed information about various crops, including planting techniques, fertilization schedules, and pest control.
   - Offer personalized recommendations based on the farmer's location, soil type, and climate.

2. **Market Prices and Trends**:
   - Include real-time market prices for different crops.
   - Show historical trends and predictions to help farmers make informed decisions about selling their produce.

3. **Weather Forecasting**:
   - Integrate weather APIs to provide accurate forecasts.
   - Farmers can plan their activities (like planting, irrigation, and harvesting) based on weather conditions.

4. **Pest and Disease Identification**:
   - Include a feature where farmers can upload images of affected crops.
   - The app can identify pests, diseases, and recommend appropriate treatments.

5. **Community Forums and Expert Interaction**:
   - Create a space where farmers can ask questions, share experiences, and seek advice.
   - Invite agricultural experts to participate and provide guidance.

6. **Crop Monitoring and Alerts**:
   - Allow farmers to set up alerts for critical events (e.g., frost warnings, excessive rainfall, or drought).
   - Monitor crop health and notify farmers of any anomalies.

7. **Government Schemes and Subsidies**:
   - Provide information about government schemes, subsidies, and grants available for farmers.
   - Help farmers apply for relevant programs.

8. **Soil Health Assessment**:
   - Offer tools to assess soil health (e.g., pH levels, nutrient content).
   - Suggest soil amendments and fertilizers accordingly.

9. **Marketplace for Seeds, Fertilizers, and Equipment**:
   - Create a platform where farmers can buy/sell seeds, fertilizers, and machinery.
   - Facilitate direct transactions between farmers and suppliers.

10. **Localized Content and Languages**:
    - Ensure the app supports local languages and dialects.
    - Provide content relevant to the specific region or state.

11. **Educational Content and Training Videos**:
    - Include tutorials, videos, and articles on modern farming practices.
    - Cover topics like sustainable agriculture, organic farming, and efficient water usage.

12. **Farm Management Tools**:
    - Track expenses, income, and profits.
    - Manage farm tasks, schedules, and labor.

13. **Offline Mode**:
    - Many rural areas have limited internet connectivity. Include an offline mode for essential features.

14. **Feedback and Ratings**:
    - Encourage farmers to rate and review the app.
    - Use feedback to improve and enhance features.

Remember that user research and feedback are crucial. Involve farmers during the development process to understand their needs better. Good luck with your app! 🌾📱

Source: Conversation with Bing, 5/8/2024
(1) Best Agricultural Mobile Apps for Farmers 2023: A Beginner’s Guide. https://indidime.com/blog/best-agricultural-mobile-apps-for-farmers/.
(2) AGRIO APP: An Advanced Android Application For Farmers - IJCRT. https://ijcrt.org/papers/IJCRT2006064.pdf.
(3) Top 5 best android apps for Indian farmers/agriculture 2022 - YourStory. https://yourstory.com/mystory/e374fa4df7-top-5-best-android-app.
(4) Apps that Revolutionize Indian Agriculture. https://justagriculture.in/files/newsletter/001.%20Apps%20that%20Revolutionize%20Indian%20Agriculture.pdf.
(5) 5 Must-have Features in an Agriculture App for Farmers. https://khetibuddy.com/top-5-features-in-an-agriculture-app/.

names - 

AgroPulse: Pulsating with agricultural insights.
FarmSage: Wise advice and guidance for farmers.

Bhūmi (भूमि): Signifying land or soil, essential for farming.
Kṣetra (क्षेत्र): Another term for agricultural land.

---------------

project - 
requirements - 

customer should be able to register by village name.

portal should give the environment variables of that particular village.

customer should be able to register by using the android inbuilt geolocation api.

village should have taluka and district data and longitude and latitude of the village. 

-------

1) developed a microservices architecture using Java and Spring Boot to separate functionalities like customer eligibility, information delivery, and features into individual modules.

customer eligibility - Id based verification like addhar, pan. 
Customer information.


"Information delivery" refers to the process of providing relevant information or content to users. In the context of a microservices architecture, it means creating services that handle the distribution of information or data to customers, such as news, updates, educational content, or personalized insights.

Customer Eligibility Module
The Customer Eligibility module is a microservice that determines if a customer qualifies for certain products or services. This involves:

Validating Customer Data: Checking the customer's information to ensure it meets required criteria.
Eligibility Criteria: Applying specific rules or conditions to assess eligibility (e.g., age, income, credit score).
Returning Status: Providing a clear eligibility status (eligible or not) based on the evaluation.
Features Module
The Features module is a microservice that manages the various features available to customers. This includes:

Feature Management: Keeping track of all available features and their configurations.
Customer Features: Assigning specific features to customers based on their eligibility or subscription level.
Enable/Disable Features: Allowing features to be turned on or off for individual customers as needed.

-----

Views - 

Sure! Here’s a comprehensive explanation of MySQL views that should help you clear an interview:

### What is a View in MySQL?

A view in MySQL is a virtual table that is created based on the result set of a SQL query. It does not store the data itself but provides a way to present data in a specific format. Views are used to simplify complex queries, enhance security by restricting access to certain data, and provide a consistent, reusable interface for data access.

### Key Points about MySQL Views

1. **Virtual Table**: A view behaves like a table but does not store data physically. It dynamically retrieves data from the underlying tables whenever accessed.
2. **Simplification**: Views simplify complex queries by encapsulating them into a single, reusable entity. This can make queries more readable and maintainable.
3. **Security**: Views can restrict access to specific rows and columns, enhancing data security. Users can be granted access to a view without giving them direct access to the underlying tables.
4. **Reusability**: Once created, views can be reused in multiple queries, promoting consistency and reducing redundancy.

### Creating a View

To create a view, you use the `CREATE VIEW` statement followed by the view name and the `SELECT` query that defines the view.

#### Syntax:
```sql
CREATE VIEW view_name AS
SELECT column1, column2, ...
FROM table_name
WHERE condition;
```

#### Example:
Assume we have a table named `employees` with the following structure:
```sql
CREATE TABLE employees (
    id INT PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    department VARCHAR(50),
    salary DECIMAL(10, 2),
    active BOOLEAN
);
```

We can create a view to list active employees in the "Engineering" department:
```sql
CREATE VIEW active_engineers AS
SELECT first_name, last_name, salary
FROM employees
WHERE department = 'Engineering' AND active = true;
```

### Using a View

Once a view is created, you can query it just like a regular table:
```sql
SELECT * FROM active_engineers;
```

### Updating a View

You can modify an existing view using the `ALTER VIEW` statement.

#### Syntax:
```sql
ALTER VIEW view_name AS
SELECT column1, column2, ...
FROM table_name
WHERE condition;
```

#### Example:
```sql
ALTER VIEW active_engineers AS
SELECT first_name, last_name, salary, department
FROM employees
WHERE department = 'Engineering' AND active = true;
```

### Dropping a View

To remove a view, use the `DROP VIEW` statement.

#### Syntax:
```sql
DROP VIEW view_name;
```

#### Example:
```sql
DROP VIEW active_engineers;
```

### Advantages of Using Views

1. **Simplifies Complex Queries**: Views can encapsulate complex joins, aggregations, and subqueries into a single entity.
2. **Security**: By creating views, you can expose only the necessary data to users, hiding sensitive information.
3. **Data Abstraction**: Views can present data in a different structure or format than the underlying tables.
4. **Consistency**: Views ensure that a consistent query is used across different parts of an application.

### Limitations of Views

1. **Performance**: Views do not store data, so each access involves executing the underlying query. This can impact performance if the query is complex.
2. **Read-Only Views**: Some views are inherently read-only, especially if they involve joins, aggregations, or certain functions. Updates, inserts, or deletes may not be allowed directly on such views.
3. **Dependency Management**: Changes to underlying tables (e.g., column renames, drops) can break views that depend on them.

### Conclusion

Understanding and using views in MySQL is crucial for simplifying data access, enhancing security, and ensuring consistency. They offer a powerful way to abstract and encapsulate complex queries, making them an invaluable tool in a database developer’s toolkit.

By explaining views clearly and providing practical examples, you can demonstrate your proficiency in managing and utilizing views in MySQL during an interview.


Window functions - 



-------------


Revision - 

Revise after the class and try to recall the information before solving the assignment.

Next day of the lecture day again revise and recall the content.

and again revise once in a month and try to recall.

DSA - revision content - https://docs.google.com/document/d/19mWysmys4DdFfUtd97tCfiTziQuuubAxvSVRqvC2F5s/edit?usp=sharing

Interviewer is always interested in the how you got the solution rather than directly jumping into the solution.

kumar.aman@scaler.com


in dsa explain your understanding of the question with the few edge cases. 

then explain the brute force do not code it.

and then get the optimised code and talk while coding like explain why you are writing particular line.

for interview practice give peer to peer interviews on promp and Interview Bit.

Resume - in resume while adding experience try to put it using STAR method. Situation, Test, Action, Result.

use resume verifiacation for getting resume reviewed.

find out use cases of the AI.

build video transcripts, or a chatbot which will store the information from the video and then answer questions based on that.

go through career module classes from dashboard to buld linkedin and resume.

build projects, showcase your programming skills.

mohit.sharma@scaler.com


--------------------

Explore concurrent package in java for the synchronized options of the collections. 

---------------------

build portfolio - 

take efforts to differentiate yourself from others.

Build in public, learn in public

kaggle profile, github, leetcode, linkedin

read articles and post its summary on linkedin.

create content and engage in comments or in other ways.

engage to other peoples content.

projects - always good to share what you have done and what you are interest into. 

avoid pleasantaries in messages.

project should be solving more real time.

show recruiter that your love what you do.

CV detailed writeups like videos, blogs etc.

attend hackathons.

be active on twitter.

explore gpt not chatgpt.
also explore copilot.

show proof of your work.

add personal experiences while posting content on the socials.

see what smart people are doing and follow them content wise.

start enganging with the content of the hr who is posting jobs on linkedin, approach to the hr on linkedin.

identify a job post and tell them how you are great guy and show your work.

amazon party rock to build gen ai portfolio.

joins groups in linkedin and communities.

show prototypes.

do follow ups with the people.

its okay to have rejections.

Have vocal communication.

---------------------


AWS

00:45:59

--------

react - 

ResultModal.jsx ->

 const ResultModal = forwardRef( function ResultModal({result, targetTime}, ref) {

return ( <dialog ref={ref} > 
<h2> You {result}</h2>
<p> The target time was <strong>{targetTime} seconds. </strong> </p>


<p> you stopped the timer with <strong> x seconds left. </strong> </p>
<form method="dialog"> 
<button> Close </button>
</form>
</dialog> );
} ) 

export default ResultModal;


App.jsx ->


import { forwardRef } from 'react';

export default funciton App(){

const dialog = useRef();

function handleStart(){
dialog.current.showModal();
}


return ( <> <ResultModal  ref={dialog} targetTime={targetTime} result="lost" />

<section> <button onClick={ handleStart} > </button> </section> 
</> );

} 


in above we are using the forwardRef for forwarding the ref to other componennt because we can not pass the ref as a prop.

we can do above with the help of useImperativeHandle hook - 

in this we are accessing child ref in parent ref to make it visible.

To enhance the `ResultModal` component to close it when the ESC button is pressed, you can add an event listener for the `keydown` event and check if the pressed key is the ESC key. If it is, you can close the modal by calling the `close()` method on the dialog element. You should also ensure to clean up the event listener when the component is unmounted to prevent memory leaks.

Here’s how you can do it:

### `ResultModal.jsx`

```jsx
import { forwardRef, useImperativeHandle, useRef, useEffect } from 'react';

const ResultModal = forwardRef(function ResultModal({ result, targetTime }, ref) {
  const dialog = useRef();

  useImperativeHandle(ref, () => ({
    open() {
      dialog.current.showModal();
    },
    close() {
      dialog.current.close();
    },
  }));

  useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === 'Escape') {
        dialog.current.close();
      }
    };

    document.addEventListener('keydown', handleKeyDown);

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, []);

  return (
    <dialog ref={dialog}>
      <h2>You {result}</h2>
      <p>
        The target time was <strong>{targetTime} seconds.</strong>
      </p>
      <p>
        You stopped the timer with <strong>x seconds left.</strong>
      </p>
      <form method="dialog">
        <button>Close</button>
      </form>
    </dialog>
  );
});

export default ResultModal;
```

### `App.jsx`

```jsx
import React, { useRef } from 'react';
import ResultModal from './ResultModal';

const targetTime = 30; // Example target time, you can adjust as needed

export default function App() {
  const dialog = useRef();

  function handleStart() {
    dialog.current.open();
  }

  return (
    <>
      <ResultModal ref={dialog} targetTime={targetTime} result="lost" />
      <section>
        <button onClick={handleStart}>Open Modal</button>
      </section>
    </>
  );
}
```

### Explanation

1. **`useEffect` Hook for Event Listener**:
   - In `ResultModal`, the `useEffect` hook adds an event listener for the `keydown` event when the component mounts.
   - The `handleKeyDown` function checks if the pressed key is the ESC key (`event.key === 'Escape'`). If it is, the modal is closed by calling `dialog.current.close()`.

2. **Clean Up**:
   - The event listener is removed when the component unmounts to avoid memory leaks, ensuring proper cleanup.

3. **Imperative Handle**:
   - The `useImperativeHandle` hook exposes two methods: `open` and `close`, allowing the parent component to control the modal.

4. **Parent Component**:
   - In `App.jsx`, the `handleStart` function calls `dialog.current.open()` to open the modal.

This enhancement makes the modal component more user-friendly by allowing it to be closed using the ESC key, providing a better user experience.

More on useImperativeHandle - 

The `useImperativeHandle` hook in React is a powerful tool used to customize the instance value that is exposed when using `ref` in functional components. This can be particularly useful when you want to expose certain methods or properties to parent components, allowing them to interact with a child component's internal state or methods without breaking the encapsulation provided by the functional component.

### Syntax

```jsx
useImperativeHandle(ref, createHandle, [deps])
```

- **ref**: The ref object passed from the parent component.
- **createHandle**: A function that returns an object containing the imperative methods you want to expose.
- **deps**: An optional array of dependencies that, when changed, will trigger the `createHandle` function to be re-evaluated.

### Example Usage

Here is a simple example demonstrating how to use `useImperativeHandle`:

#### Child Component

```jsx
import React, { useImperativeHandle, useRef, forwardRef } from 'react';

const FancyInput = forwardRef((props, ref) => {
  const inputRef = useRef();

  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus();
    },
    clear: () => {
      inputRef.current.value = '';
    }
  }));

  return <input ref={inputRef} {...props} />;
});

export default FancyInput;
```

#### Parent Component

```jsx
import React, { useRef } from 'react';
import FancyInput from './FancyInput';

const ParentComponent = () => {
  const inputRef = useRef();

  return (
    <div>
      <FancyInput ref={inputRef} />
      <button onClick={() => inputRef.current.focus()}>Focus Input</button>
      <button onClick={() => inputRef.current.clear()}>Clear Input</button>
    </div>
  );
};

export default ParentComponent;
```

### Explanation

1. **Forwarding the Ref**:
    - The child component `FancyInput` uses `forwardRef` to forward the ref to the inner `input` element.
    - `forwardRef` is necessary to pass refs from parent components to child components.

2. **Creating the Handle**:
    - Inside the `FancyInput` component, the `useImperativeHandle` hook is used to expose the `focus` and `clear` methods.
    - These methods are defined in an object returned by the `createHandle` function and can be invoked by the parent component.

3. **Using the Ref in the Parent Component**:
    - The parent component `ParentComponent` creates a ref (`inputRef`) and attaches it to the `FancyInput` component.
    - The buttons in the parent component can call the methods (`focus` and `clear`) exposed by the child component using the ref.

### Key Points

- **Encapsulation**: `useImperativeHandle` allows you to encapsulate internal details of the child component while providing a controlled way to interact with it from the outside.
- **Performance**: By passing a dependency array, you can optimize when the imperative handle is recalculated, avoiding unnecessary recalculations.
- **Safety**: The methods exposed through `useImperativeHandle` should be used carefully to maintain the predictability and readability of your component's behavior.

In summary, `useImperativeHandle` is useful when you need to expose specific methods or properties of a functional component to parent components, while keeping the internal implementation details hidden. This helps in building more maintainable and encapsulated components.

when to use state and when to use ref - 

In React, state and refs serve different purposes and are used in different scenarios. Here's a comprehensive guide on when to use state and when to use refs:

### When to Use State

State is used to store data that affects the rendering of your component and can change over time. It is the heart of React's reactivity and causes components to re-render when the state changes.

**Use state when:**

1. **Data Affects Rendering**:
   - Any data that should cause the component to re-render when it changes should be stored in the state. This includes user inputs, fetched data, and any dynamic data that influences what gets displayed.

   ```jsx
   import React, { useState } from 'react';

   const Counter = () => {
     const [count, setCount] = useState(0);

     return (
       <div>
         <p>{count}</p>
         <button onClick={() => setCount(count + 1)}>Increment</button>
       </div>
     );
   };
   ```

2. **Component Lifecycle**:
   - State can be used to manage data throughout the lifecycle of a component. For example, you can set initial state values in the `useState` hook, update state in response to user interactions or lifecycle events, and clean up in `useEffect`.

3. **Interdependent State Changes**:
   - When state values depend on each other or need to be derived from each other, you should use state. React ensures that state updates are handled in a predictable way.

4. **Triggering Side Effects**:
   - State changes can trigger side effects managed by the `useEffect` hook. For example, fetching data when a component mounts or when a specific state changes.

### When to Use Refs

Refs provide a way to access and manipulate DOM elements or store mutable values that don't trigger re-renders when changed.

**Use refs when:**

1. **Directly Accessing DOM Elements**:
   - Use refs to access and manipulate DOM elements directly. This is common for handling focus, text selection, media playback, animations, and integrating with third-party libraries that require direct DOM manipulation.

   ```jsx
   import React, { useRef } from 'react';

   const TextInput = () => {
     const inputRef = useRef();

     const focusInput = () => {
       inputRef.current.focus();
     };

     return (
       <div>
         <input ref={inputRef} type="text" />
         <button onClick={focusInput}>Focus Input</button>
       </div>
     );
   };
   ```

2. **Storing Mutable Values**:
   - Refs are useful for storing mutable values that should not trigger a re-render when they change. For example, you can store a timeout ID, a previous value, or a mutable counter.

   ```jsx
   import React, { useState, useRef, useEffect } from 'react';

   const Timer = () => {
     const [count, setCount] = useState(0);
     const intervalRef = useRef();

     useEffect(() => {
       intervalRef.current = setInterval(() => {
         setCount(prevCount => prevCount + 1);
       }, 1000);

       return () => clearInterval(intervalRef.current);
     }, []);

     return <div>{count}</div>;
   };
   ```

3. **Avoiding Re-Renders**:
   - If you need to persist a value between renders but don't want to cause a re-render when it changes, use a ref. This is particularly useful for performance optimizations and avoiding unnecessary updates.

### Summary

- **Use State**:
  - When the data affects rendering.
  - For managing component lifecycle data.
  - For interdependent state changes.
  - When state changes should trigger side effects.

- **Use Refs**:
  - For directly accessing and manipulating DOM elements.
  - To store mutable values that don't require re-rendering.
  - To avoid re-renders for performance reasons.

By understanding these distinctions, you can make better decisions on whether to use state or refs in your React components, leading to cleaner and more efficient code.

Portals -  

---------


go through sonarQube for generating the testing report, code coverage and integrate it in the project.

Github actions helps in automatically testing.

---------------


Class diagram of ATM and Elevator system.
5 DSA problems.
Revision for java mock.


ATM - 

requirements - 

user should be able to withdraw the money using debit card.

there should be an option to enter the amount and password.

admin of the bank should be able to add money in the ATM.

user should be able to check the balance

user should be able to change the password


--------

Backend projects: Using Kafka for ASync Comms

youtube does below operations on the video when we upload a new video - 

Save the video
check for copyright infringe
Transocde it into low quality videos
generate captions

youtube will perform all of the above mentioned operations and once all the operations are completed then send the response back to the user.

if we do all the operations one by one then it is synchronous.

or we can take the video and then store it in the database and once it is stored we will send the acknowledgement to the user that video is uploaded. and perform all the remaning operations we can perform on the video parallely or asynchronously. This will improve the video processing time. 


cons of synchronous - 
user will have to wait longer for the response.

Every request takes some amount of ram in the server, if the response takes time then more ram will be consumed on the server side.

2) Place an order at amazon - 

	it will call the below services

Inventory services
Logistic Services
Notification Service
Delivery Service

all the above services will be called asynchronously after giving confirmation to the client.

for asynchronous communication we can use message queues. 

Message queue are kafka, Rabit mq, SQS.

In the context of Apache Kafka, the terms **synchronous** and **asynchronous** refer to the ways producers and consumers handle messages.

### Synchronous Communication in Kafka

**Synchronous communication** implies that the producer or consumer waits for a confirmation before proceeding to the next task. This can ensure that messages are processed in a strict order and that each message is successfully sent or consumed before moving on.

**Synchronous Producer**:
- When a producer sends a message synchronously, it waits for a confirmation from Kafka that the message has been received and committed to the log.
- This is often done using the `send` method followed by the `get` method, which blocks until the message is acknowledged.
- **Pros**: Ensures that messages are successfully sent before proceeding, making error handling straightforward.
- **Cons**: Can lead to higher latency and lower throughput because the producer waits for each message to be acknowledged.

Example:
```java
ProducerRecord<String, String> record = new ProducerRecord<>("topic", "key", "value");
try {
    producer.send(record).get(); // Blocks until Kafka confirms receipt
} catch (Exception e) {
    e.printStackTrace();
}
```

**Synchronous Consumer**:
- A synchronous consumer processes each message in sequence and waits for the processing of each message to complete before fetching the next one.
- **Pros**: Ensures order and simplifies error handling.
- **Cons**: Can be slower since it waits for each message to be processed.

### Asynchronous Communication in Kafka

**Asynchronous communication** allows the producer or consumer to proceed without waiting for a confirmation. This can lead to higher throughput and lower latency but requires more sophisticated error handling.

**Asynchronous Producer**:
- When a producer sends a message asynchronously, it does not wait for a confirmation and can send multiple messages in quick succession.
- This is done using the `send` method with a callback function to handle success or failure.
- **Pros**: Higher throughput and lower latency since the producer doesn't wait for acknowledgments.
- **Cons**: More complex error handling, as failures are handled asynchronously.

Example:
```java
ProducerRecord<String, String> record = new ProducerRecord<>("topic", "key", "value");
producer.send(record, new Callback() {
    public void onCompletion(RecordMetadata metadata, Exception e) {
        if (e != null) {
            e.printStackTrace();
        } else {
            System.out.println("Message sent to partition " + metadata.partition() + " with offset " + metadata.offset());
        }
    }
});
```

**Asynchronous Consumer**:
- An asynchronous consumer can fetch and process messages concurrently, often using a separate thread or a thread pool for processing.
- **Pros**: Higher throughput as multiple messages can be processed concurrently.
- **Cons**: More complex to maintain order and handle errors.

### Summary

- **Synchronous** communication in Kafka involves waiting for acknowledgments before proceeding. It's easier to handle errors and maintain order but can be slower due to the wait time.
- **Asynchronous** communication allows for higher throughput and lower latency by not waiting for acknowledgments. It requires more complex error handling and can be less straightforward in maintaining order.



Apache Kafka is a distributed event streaming platform capable of handling trillions of events a day. It is primarily used for building real-time data pipelines and streaming applications. Kafka is designed to handle a high throughput of messages, provide low latency, and ensure data durability.

### Key Components and Terms

#### 1. **Producer**
A Kafka producer is an application that sends messages to one or more Kafka topics. Producers are responsible for choosing which record to assign to which partition within a topic.

**Key Concepts**:
- **Topic**: A category or feed name to which records are sent.
- **Partition**: Each topic is split into partitions to allow scalability. Each partition is an ordered sequence of records.
- **Record**: A single message or event sent by a producer.

#### 2. **Consumer**
A Kafka consumer is an application that reads records from Kafka topics. Consumers subscribe to one or more topics and process the feed of published messages.

**Key Concepts**:
- **Consumer Group**: A group of consumers that work together to consume records from a topic. Each consumer in a group is assigned a subset of the partitions to balance the load.
- **Offset**: A unique identifier for a record within a partition. Consumers track offsets to ensure they process records in the correct order and can resume from where they left off.

#### 3. **Broker**
A Kafka broker is a server that hosts Kafka partitions. Brokers receive records from producers, store them on disk, and serve them to consumers. A Kafka cluster consists of multiple brokers.

**Key Concepts**:
- **Cluster**: A group of Kafka brokers working together. A cluster provides fault tolerance and high availability.
- **Leader and Follower**: For each partition, one broker is designated as the leader, and others as followers. The leader handles all read and write requests for the partition, while followers replicate the data.

#### 4. **Topic**
A topic is a logical channel to which records are sent by producers and from which records are consumed by consumers. Topics can have multiple partitions, allowing parallel processing of records.

**Key Concepts**:
- **Replication Factor**: The number of copies of each partition stored across different brokers. Higher replication factors increase fault tolerance.
- **Retention Policy**: Determines how long Kafka retains records. Policies can be based on time (e.g., keep records for seven days) or size (e.g., keep records until they reach a certain size).

#### 5. **Partition**
Partitions are subdivisions of topics that enable Kafka to scale horizontally. Each partition is an ordered log of records and is replicated across multiple brokers for fault tolerance.

**Key Concepts**:
- **Partitioning Strategy**: Determines how records are distributed across partitions. Common strategies include round-robin and key-based partitioning.
- **Log**: An ordered sequence of records within a partition. Logs are append-only and immutable.

#### 6. **ZooKeeper**
Apache ZooKeeper is used by Kafka to manage and coordinate the brokers. ZooKeeper handles metadata, such as configuration settings and partition leader elections.

#### 7. **Connect**
Kafka Connect is a framework for integrating Kafka with external systems. It provides ready-made connectors for various data sources and sinks, such as databases, file systems, and cloud services.

**Key Concepts**:
- **Source Connector**: Captures data from an external system and sends it to Kafka.
- **Sink Connector**: Consumes data from Kafka and sends it to an external system.

#### 8. **Streams**
Kafka Streams is a client library for building real-time applications and microservices. It allows you to process data stored in Kafka with complex event processing, stateful transformations, and real-time analytics.

**Key Concepts**:
- **Stream**: A continuous flow of records.
- **Table**: Represents state derived from streams. It supports stateful operations, such as joins and aggregations.
- **Processor API**: Provides fine-grained control over stream processing, allowing custom processing logic.

#### 9. **Schema Registry**
The Schema Registry is a component that manages schemas for Kafka records. It ensures data compatibility and helps with the serialization and deserialization of records.

**Key Concepts**:
- **Avro**: A common serialization format used with the Schema Registry.
- **Compatibility Modes**: Define how schemas can evolve over time (e.g., backward compatibility, forward compatibility).

### How Kafka Works

1. **Producers** send records to Kafka topics. The records are distributed across partitions, either based on keys (if specified) or using a round-robin algorithm.
2. **Brokers** receive the records and store them in partition logs. Each partition has a leader broker that handles all read and write operations, while follower brokers replicate the data.
3. **Consumers** subscribe to topics and read records from the partitions. Kafka ensures that each partition is consumed by only one consumer in a consumer group, enabling parallel processing.
4. **ZooKeeper** manages the cluster metadata and handles broker coordination tasks, such as leader election.
5. **Kafka Connect** integrates Kafka with external systems, using connectors to ingest data into Kafka and export data from Kafka.
6. **Kafka Streams** processes data in real-time, allowing the building of sophisticated stream processing applications.

### Use Cases

- **Real-Time Analytics**: Kafka enables real-time processing and analytics of data streams, such as user activity logs, financial transactions, and sensor data.
- **Data Integration**: Kafka Connect integrates disparate data sources and sinks, providing a unified data pipeline.
- **Event Sourcing**: Kafka's log-based storage and ordered records make it suitable for event sourcing architectures.
- **Microservices Communication**: Kafka acts as a messaging backbone for microservices, enabling decoupled and scalable communication.

Kafka's design principles—scalability, fault tolerance, high throughput, and low latency—make it a powerful tool for handling real-time data streams and building modern data architectures.


now our Order service will have to call all the operation listed above one by one or it will push all the events inside the queue .

the one which push the events in the queue is called as publisher.  

and on the other side there are multiple subscribers in the kafka like Email service, inventory service etc.

the subscribers need to subscribe to the particular topic to listen to that event.


consumer is nothing but the piece of code which runs when ever a perticular type of event is executed / pushed inside a queue.

 
uses of using queue - 

lesser usage of resources
Service can be scaled independently.


implementation of the kafka - 

install kafka.

then add kafka dependency to the pom.xml

<!-- https://mvnrepository.com/artifact/org.springframework.kafka/spring-kafka -->
<dependency>
    <groupId>org.springframework.kafka</groupId>
    <artifactId>spring-kafka</artifactId>
    <version>3.2.1</version>
</dependency>


create kafka config - 

KafkaProducerConfig - 

@Configuration
public class KafkaProducerConfig {

private KafkaTemplate<string, String> kafkaTemplate;


public kafkaProducerConfig( KafkaTemplate<String, String> kafkaTemplate) {
this.kafkaTemplate = kafkaTemplate;
}

public void publishEvent( String topic , String message) {
kafkaTemplate.send( topic, message);

}

01:41:54

-----------


Resume improvements - 


1) Designed and implemented RESTful APIs using Java and Spring Boot to efficiently handle
customer information, resulting in a 20% reduction in response time.


response - 

Sure, let's go into more depth for each aspect of the experience detail, focusing on specific customer details APIs, identifying bottlenecks, and explaining how they were handled and measured.

### Experience Detail
**Designed and implemented RESTful APIs using Java and Spring Boot to efficiently handle customer information, resulting in a 20% reduction in response time.**

### Detailed Requirement to Justify the Experience (Based on Existing System)

**Requirement:**
To enhance the performance and scalability of our existing insurance operations system, we need to optimize and refactor the current suite of RESTful APIs using Java and Spring Boot. These APIs handle customer information, including personal details, policy data, claims history, and financial transactions. The key objectives and tasks for this requirement are as follows:

1. **Performance Optimization:**
   - **Objective:** Improve the response time of existing APIs by 20%.
   - **Tasks:**
     - **Identify bottlenecks:** Analyze current API performance using monitoring tools such as New Relic or Prometheus. Focus on the APIs for retrieving customer personal details and policy data, which were causing significant delays.
       - **Customer Personal Details API:** This API was identified as a bottleneck due to its high frequency of requests and the complexity of the data it handled. The API retrieved comprehensive customer profiles, including contact information, demographic data, and account statuses.
       - **Policy Data API:** This API handled policy-related information, such as policy terms, coverage details, and premium calculations. It was causing delays due to complex join operations on multiple database tables.
     - **Optimize data retrieval:**
       - **Customer Personal Details API:** 
         - **Efficient Query Techniques:** Simplified and optimized SQL queries to reduce the number of joins and improve execution time.
         - **Indexing:** Added indexes to the frequently queried fields, such as customer ID and account status, to speed up query execution.
         - **Caching:** Implemented Redis caching to store frequently accessed customer profiles, reducing database load and improving response times.
       - **Policy Data API:**
         - **Data Denormalization:** Denormalized certain policy data to reduce the complexity of joins and improve read performance.
         - **Batch Processing:** Implemented batch processing for policy updates to reduce the load on the API during peak times.
         - **Async Processing:** Used asynchronous processing for non-critical data retrieval tasks to improve API responsiveness.
     - **Load Testing:** Conduct load testing using tools like JMeter to measure the improvements in response times and identify any remaining performance issues.

2. **Scalability Enhancements:**
   - **Objective:** Increase the scalability of the APIs to handle a growing number of users and data.
   - **Tasks:**
     - **Microservices Architecture:** Decompose the monolithic API components into smaller, more manageable microservices. For instance, separate the customer profile management from policy data management to enhance modularity.
     - **Horizontal Scaling:** Design the APIs to support horizontal scaling by deploying them across multiple instances in a Kubernetes cluster.
     - **Load Balancing:** Implement load balancing using tools like NGINX or AWS Elastic Load Balancing to distribute incoming traffic evenly across API instances.

3. **Security and Data Integrity:**
   - **Objective:** Ensure the APIs maintain high standards of security and data integrity.
   - **Tasks:**
     - **Security Audit:** Conduct a thorough security audit using tools like OWASP ZAP to identify and address vulnerabilities in the existing APIs.
     - **Access Control:** Implement OAuth 2.0 and JWT for robust authentication and authorization mechanisms to protect sensitive customer data.
     - **Data Validation:** Enhance data validation and sanitization processes using frameworks like Hibernate Validator to prevent security threats.
     - **Encryption:** Ensure data encryption in transit using TLS and at rest using database-level encryption to protect customer information.

4. **Documentation and Testing:**
   - **Objective:** Improve the maintainability and reliability of the APIs through comprehensive documentation and testing.
   - **Tasks:**
     - **Update Documentation:** Document all changes made to the APIs, including new endpoints, updated request/response formats, and usage guidelines using Swagger/OpenAPI.
     - **Unit Testing:** Write and update unit tests using JUnit and Mockito to cover new and existing functionalities, ensuring robust error handling and edge case management.
     - **Integration Testing:** Conduct integration testing using tools like Postman and RestAssured to ensure seamless interaction between the APIs and other system components.
     - **Performance Testing:** Perform regular performance testing using JMeter to validate ongoing improvements and maintain optimal performance.

5. **Collaboration and Deployment:**
   - **Objective:** Ensure smooth deployment and collaboration across the development team.
   - **Tasks:**
     - **Code Reviews:** Participate in code reviews to maintain high-quality standards and share knowledge within the team.
     - **CI/CD Pipelines:** Implement and maintain continuous integration and continuous deployment pipelines using Jenkins or GitLab CI/CD to automate the testing and deployment process.
     - **Monitoring and Feedback:** Set up monitoring tools like Grafana and Prometheus to track API performance and gather feedback from end-users to identify further improvement areas.

**Metrics Calculation:**
- **Response Time Reduction:** Measured the average response time of the APIs before and after optimization using monitoring tools. Calculated the percentage reduction by comparing the two metrics.
- **Data Retrieval Speed Improvement:** Analyzed database query execution times before and after optimization to measure improvements in data retrieval speed.
- **System Modularity and Scalability:** Tracked the system's ability to handle increased load and traffic by monitoring resource utilization and response times during load testing.
- **Post-Deployment Issues:** Compared the number of post-deployment issues reported before and after implementing comprehensive unit tests to measure the decrease in issues.

By focusing on these objectives and tasks, we significantly enhanced the performance, scalability, and security of the existing APIs, resulting in a 20% reduction in response time and improved overall system efficiency.


2) Developed a microservices architecture using Java and Spring Boot to segregate
functionalities, leading to a 30% increase in system modularity and scalability - 

Response - 

Great, let's move on to the next experience detail from your resume.

### Experience Detail
**Developed a microservices architecture using Java and Spring Boot to segregate functionalities, leading to a 30% increase in system modularity and scalability.**

### Detailed Requirement to Justify the Experience

**Requirement:**
To improve the modularity and scalability of our existing insurance operations system, we need to refactor the current monolithic architecture into a microservices-based architecture using Java and Spring Boot. This will allow us to segregate functionalities and enhance the system's ability to scale and adapt to changing business needs. The key objectives and tasks for this requirement are as follows:

1. **Microservices Architecture Design:**
   - **Objective:** Design a microservices architecture to replace the existing monolithic system, leading to a 30% increase in modularity and scalability.
   - **Tasks:**
     - **System Analysis:** Conduct a thorough analysis of the existing monolithic system to identify the core functionalities and their interdependencies.
     - **Service Identification:** Identify and define individual services that can be extracted from the monolithic application. For example, separate services for customer management, policy management, claims processing, and payment processing.
     - **Service Boundaries:** Establish clear boundaries for each service to ensure loose coupling and high cohesion.

2. **Implementation of Microservices:**
   - **Objective:** Implement the identified microservices using Java and Spring Boot.
   - **Tasks:**
     - **Service Development:** Develop each service independently using Spring Boot, ensuring that each service has its own database and is independently deployable.
     - **API Gateway:** Implement an API gateway using Spring Cloud Gateway to handle routing, load balancing, and security for incoming requests.
     - **Inter-Service Communication:** Use RESTful APIs and asynchronous messaging (e.g., RabbitMQ or Kafka) for inter-service communication to ensure scalability and reliability.
     - **Service Discovery:** Implement service discovery using tools like Netflix Eureka or Consul to enable services to find and communicate with each other dynamically.

3. **Database Management:**
   - **Objective:** Ensure data consistency and integrity across microservices.
   - **Tasks:**
     - **Database per Service:** Adopt the database-per-service pattern to ensure that each microservice manages its own data independently, improving modularity and scalability.
     - **Data Synchronization:** Implement eventual consistency and data synchronization mechanisms using events and messaging queues to ensure data integrity across services.
     - **Schema Evolution:** Develop strategies for schema evolution and database migrations to handle changes in data structures without downtime.

4. **Security and Monitoring:**
   - **Objective:** Enhance the security and monitoring capabilities of the microservices architecture.
   - **Tasks:**
     - **Security Implementation:** Implement security best practices, including OAuth 2.0 for authentication and authorization, SSL/TLS for data encryption, and role-based access control (RBAC) for service access management.
     - **Logging and Monitoring:** Use tools like ELK Stack (Elasticsearch, Logstash, Kibana) and Prometheus/Grafana for centralized logging and monitoring of microservices to detect and diagnose issues quickly.
     - **Health Checks:** Implement health checks for each microservice to monitor their status and ensure high availability using Spring Boot Actuator.

5. **Testing and Deployment:**
   - **Objective:** Ensure robust testing and smooth deployment of microservices.
   - **Tasks:**
     - **Unit and Integration Testing:** Write comprehensive unit and integration tests for each microservice using JUnit and Mockito to ensure their correctness and reliability.
     - **CI/CD Pipelines:** Implement continuous integration and continuous deployment (CI/CD) pipelines using Jenkins or GitLab CI/CD to automate the build, test, and deployment process.
     - **Containerization:** Use Docker to containerize microservices and Kubernetes to orchestrate their deployment and scaling.

**Metrics Calculation:**
- **System Modularity:** Measured by the number of independent, deployable services and the reduction in inter-service dependencies.
- **Scalability:** Evaluated through load testing and monitoring resource utilization during peak times to ensure the system can handle increased traffic.
- **Deployment Frequency:** Tracked the frequency of successful deployments and the reduction in deployment time due to the microservices architecture.
- **Issue Resolution Time:** Monitored the average time to detect and resolve issues using centralized logging and monitoring tools.

By focusing on these objectives and tasks, we significantly enhanced the modularity and scalability of the system, leading to a 30% increase in overall system efficiency and adaptability.

3) Created and managed a database to ensure data integrity and optimal performance, resulting
in a 15% improvement in data retrieval speed.

Response - 

### Experience Detail
**Created and managed a database to ensure data integrity and optimal performance, resulting in a 15% improvement in data retrieval speed.**

### Detailed Requirement to Justify the Experience

**Requirement:**
To improve data integrity and optimize the performance of our insurance operations system, we need to design and manage an efficient database solution. This will involve ensuring data consistency, implementing performance-enhancing techniques, and optimizing data retrieval processes. The key objectives and tasks for this requirement are as follows:

1. **Database Design and Optimization:**
   - **Objective:** Create a well-structured database schema to ensure data integrity and optimize performance.
   - **Tasks:**
     - **Schema Design:** Design a normalized database schema using MySQL to handle customer information, policy data, claims history, and financial transactions. 
       - **Customer Information:** Tables for customer profiles, contact details, and demographic information.
       - **Policy Data:** Tables for policy terms, coverage details, premium calculations, and policy status.
       - **Claims History:** Tables for claims submissions, processing status, and resolution details.
       - **Financial Transactions:** Tables for payment records, transaction history, and billing information.
     - **Indexing:** Implement indexing strategies for frequently queried fields, such as customer IDs, policy numbers, and claim IDs, to enhance query performance.
     - **Partitioning:** Use table partitioning techniques to divide large tables into smaller, more manageable segments, improving query efficiency and data management.
     - **Foreign Keys and Constraints:** Define foreign keys and constraints to ensure referential integrity and prevent orphaned records.

2. **Data Integrity Management:**
   - **Objective:** Ensure the integrity and consistency of data across the database.
   - **Tasks:**
     - **Transactions:** Implement transactions using ACID (Atomicity, Consistency, Isolation, Durability) properties to ensure data consistency during complex operations.
     - **Triggers and Stored Procedures:** Develop triggers and stored procedures to automate data validation, enforce business rules, and maintain data integrity.
     - **Data Validation:** Implement data validation checks at both the application and database levels to ensure the accuracy and consistency of data entered into the system.
     - **Regular Audits:** Conduct regular data audits and consistency checks to identify and resolve data anomalies and integrity issues.

3. **Performance Tuning:**
   - **Objective:** Optimize database performance to achieve a 15% improvement in data retrieval speed.
   - **Tasks:**
     - **Query Optimization:** Analyze and optimize SQL queries to reduce execution times. Use techniques such as query rewriting, indexing, and avoiding unnecessary joins.
     - **Caching:** Implement database caching strategies to store frequently accessed data in memory, reducing the need for repetitive database queries.
     - **Connection Pooling:** Use connection pooling to manage database connections efficiently, reducing the overhead of establishing new connections for each request.
     - **Database Monitoring:** Use monitoring tools like MySQL Workbench or Percona Monitoring and Management to track database performance and identify potential bottlenecks.

4. **Backup and Recovery:**
   - **Objective:** Ensure robust backup and recovery mechanisms to protect data against loss or corruption.
   - **Tasks:**
     - **Backup Strategy:** Develop a comprehensive backup strategy, including regular full and incremental backups, to ensure data can be restored in case of failure.
     - **Automated Backups:** Implement automated backup processes to regularly back up critical data and store backups securely.
     - **Recovery Plan:** Develop and test a database recovery plan to ensure quick and efficient restoration of data in case of corruption or loss.

5. **Documentation and Testing:**
   - **Objective:** Improve maintainability and reliability of the database solution through comprehensive documentation and testing.
   - **Tasks:**
     - **Documentation:** Document the database schema, indexing strategies, stored procedures, and backup/recovery plans to ensure clear understanding and maintenance.
     - **Unit Testing:** Write unit tests for stored procedures and triggers to ensure their correct functionality and performance.
     - **Load Testing:** Conduct load testing to validate the performance improvements and ensure the database can handle high volumes of transactions efficiently.

**Metrics Calculation:**
- **Data Retrieval Speed:** Measured by monitoring the average time taken to execute data retrieval queries before and after optimization.
- **Database Query Performance:** Tracked the execution times of optimized queries using monitoring tools and compared them to baseline performance metrics.
- **Data Integrity Issues:** Monitored the number of data integrity issues and anomalies identified during regular audits to ensure consistency.
- **System Uptime:** Tracked the system uptime and the number of successful data recovery instances to ensure robust backup and recovery mechanisms.

By focusing on these objectives and tasks, we successfully created and managed a database that ensured data integrity and optimal performance, resulting in a 15% improvement in data retrieval speed.


------------------


requirements - 

user should be able to make the post for "for sell", "for rent", "for buy", "help needed" and "Informational".

post should contain text, image or video, comments, like button, share button.

user should be able to login to make the comment and create the post.

user should be able to see how many people have seen this post and other related metrics.

user has post - 1:m
user has comment - 1:m
post has comment - 1:m


classes - 

User -

id.
name.
email.
List<Post> posts.


Post - 

id.
title.
postType : PostType
description.
image or video.
List<comment> comments.
Likes
viewersCount

Comment - 
id
userId
description


Like - 
id
userId

PostType Enum - 
SELL, BUY, RENT, HELP_NEEDED, INFORMATIONAL.

functionality - 

Sign up, login, logout, forgot password, 2 factor authentication. 

search posts by title, description.

filter posts by filters like sell, buy posts.



----

login logout using JWT.
password encoder BCryptPasswordEncoder
Searching is implemented by using ElasticSearch.



https://medium.com/@tericcabrel/implement-jwt-authentication-in-a-spring-boot-3-application-5839e4fd8fac


--------

Personalized service - 

this will have the personal things of the farmer like finance management, expense and income management, Crop Management, Animal management, Knowledge management etc.


Finance Management - 

Expense Management
Earning Management



requirements -

User should be able to add crops
user should be able to add Animal

each crop will have finance management.
each animal will have the finance management.

in finance management user should be able to add the expense of that paerticular crop or animal and also user should be able to add the earning from that crop and animal.

each crop will have type like corn , millets, Soyabean, etc.

each crop will have the name.

Each animal will have the name and type like Cow, Bull, Buffelo etc.



crop will have the finance management
Animal will have the finance management.


--------

Machine Coding - 8: Code Parking Lot 2 - 



-----------

Message Template - 

Hi Reshika, 

I am looking for a Job in Java and Spring boot, backend development.

I am Dhananjay Jadhav, and I am a Software Developer with 2.3 years of experience in Java and Spring Boot. I have a strong background in developing microservices architectures and implementing secure and efficient RESTful APIs.

I think I am a good fit for this job, Please let me know if I match your requirements.

Thanks.

-----------------


DSA
Internals
Concurrency
Design patterns
Database


-----------------

Understanding Authentication Provider and Implementing it -

Why should we consider creating our own AuthenticationProvider - 

In Spring Security, an `AuthenticationProvider` is a core interface that provides a way to authenticate a user. It is responsible for validating a user's credentials and returning an `Authentication` object that contains the user's authenticated identity and authorities. The `AuthenticationProvider` can support different types of authentication mechanisms, allowing for a flexible and extensible authentication process.

### How `AuthenticationProvider` Works

1. **Authenticate Method**: The `AuthenticationProvider` interface defines a single method `authenticate(Authentication authentication)` which is used to perform the authentication logic.

```java
public interface AuthenticationProvider {
    Authentication authenticate(Authentication authentication) throws AuthenticationException;
    boolean supports(Class<?> authentication);
}
```

2. **Supports Method**: The `supports(Class<?> authentication)` method is used to determine whether the `AuthenticationProvider` can process the given authentication type.

3. **Returning Authentication**: If the authentication is successful, the `authenticate` method returns a fully populated `Authentication` object, otherwise, it throws an `AuthenticationException`.

### Handling Multiple Authentication Methods

When you have multiple authentication methods, such as OAuth2 and traditional username/password authentication, Spring Security can be configured to use multiple `AuthenticationProvider` implementations. Each `AuthenticationProvider` can be configured to handle a specific type of authentication request.

#### Scenario with OAuth2 and Username/Password Authentication

1. **Username/Password AuthenticationProvider**: This provider handles the traditional login using a username and password. It verifies the credentials against a user store (e.g., database).

```java
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.password.PasswordEncoder;

@Bean
public DaoAuthenticationProvider daoAuthenticationProvider(UserDetailsService userDetailsService, PasswordEncoder passwordEncoder) {
    DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
    provider.setUserDetailsService(userDetailsService);
    provider.setPasswordEncoder(passwordEncoder);
    return provider;
}
```

2. **OAuth2 AuthenticationProvider**: This provider handles authentication via OAuth2, typically validating tokens issued by an OAuth2 authorization server.

```java
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationProvider;
import org.springframework.security.oauth2.jwt.JwtDecoder;

@Bean
public JwtAuthenticationProvider jwtAuthenticationProvider(JwtDecoder jwtDecoder) {
    return new JwtAuthenticationProvider(jwtDecoder);
}
```

3. **Configuring the AuthenticationManager**: The `AuthenticationManager` is responsible for delegating authentication requests to the appropriate `AuthenticationProvider`. You can configure multiple providers in a Spring Security configuration class.

```java
import org.springframework.context.annotation.Bean;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;

@Bean
public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
    return authenticationConfiguration.getAuthenticationManager();
}

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(authorize -> authorize
                .anyRequest().authenticated()
            )
            .oauth2Login(withDefaults())  // For OAuth2 login
            .formLogin(withDefaults());   // For username/password login

        return http.build();
    }
}
```

4. **AuthenticationManagerBuilder**: Alternatively, you can use the `AuthenticationManagerBuilder` to configure multiple `AuthenticationProvider` instances.

```java
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@Configuration
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    private final DaoAuthenticationProvider daoAuthenticationProvider;
    private final JwtAuthenticationProvider jwtAuthenticationProvider;

    public WebSecurityConfig(DaoAuthenticationProvider daoAuthenticationProvider, JwtAuthenticationProvider jwtAuthenticationProvider) {
        this.daoAuthenticationProvider = daoAuthenticationProvider;
        this.jwtAuthenticationProvider = jwtAuthenticationProvider;
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.authenticationProvider(daoAuthenticationProvider)
            .authenticationProvider(jwtAuthenticationProvider);
    }
}
```

### How It Works in Practice

When a user attempts to authenticate, the following steps occur:

1. **Login Request**: The user submits a login request via form login (username/password) or OAuth2 login.
2. **AuthenticationManager**: The `AuthenticationManager` receives the authentication request and iterates through the configured `AuthenticationProvider` instances to find one that supports the authentication type.
3. **Provider Authentication**: The appropriate `AuthenticationProvider` processes the authentication request. For example:
   - The `DaoAuthenticationProvider` verifies the username and password against the user details service.
   - The `JwtAuthenticationProvider` validates the OAuth2 token using the JWT decoder.
4. **Authentication Success**: If authentication is successful, the `AuthenticationManager` returns an `Authentication` object with the user's identity and authorities.
5. **Authentication Failure**: If none of the `AuthenticationProvider` instances can authenticate the user, an `AuthenticationException` is thrown.

This setup allows you to seamlessly integrate multiple authentication mechanisms within your application, providing a flexible and secure authentication process.

In Spring Security, the `AuthenticationProvider` interface is a core component responsible for authenticating user credentials. It abstracts the authentication mechanism, allowing different implementations to handle various types of authentication (e.g., username/password, OAuth2 tokens, etc.).

### `AuthenticationProvider` Interface

The `AuthenticationProvider` interface defines two primary methods:

1. **authenticate**: This method is responsible for performing the authentication logic.
2. **supports**: This method indicates whether the `AuthenticationProvider` can process the given type of authentication request.

Here is the interface definition:

```java
package org.springframework.security.authentication;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;

public interface AuthenticationProvider {
    Authentication authenticate(Authentication authentication) throws AuthenticationException;
    boolean supports(Class<?> authentication);
}
```

### Methods Explained

#### authenticate

The `authenticate` method performs the actual authentication logic. It takes an `Authentication` object as input and returns a fully authenticated `Authentication` object if authentication is successful.

```java
Authentication authenticate(Authentication authentication) throws AuthenticationException;
```

- **Parameters**:
  - `authentication`: The authentication request object containing the credentials (e.g., username and password).
- **Returns**:
  - A fully authenticated `Authentication` object if authentication is successful.
- **Throws**:
  - `AuthenticationException` if authentication fails.

#### supports

The `supports` method determines whether the `AuthenticationProvider` can handle the type of `Authentication` object passed to it.

```java
boolean supports(Class<?> authentication);
```

- **Parameters**:
  - `authentication`: The class of the authentication request object.
- **Returns**:
  - `true` if the `AuthenticationProvider` can handle the given authentication type; `false` otherwise.

### Example Implementation

Here's an example of a custom `AuthenticationProvider` that authenticates users based on a username and password:

```java
package com.example.security;

import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

@Component
public class CustomAuthenticationProvider implements AuthenticationProvider {

    private final UserDetailsService userDetailsService;
    private final PasswordEncoder passwordEncoder;

    public CustomAuthenticationProvider(UserDetailsService userDetailsService, PasswordEncoder passwordEncoder) {
        this.userDetailsService = userDetailsService;
        this.passwordEncoder = passwordEncoder;
    }

    @Override
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
        String username = authentication.getName();
        String password = authentication.getCredentials().toString();

        UserDetails userDetails = userDetailsService.loadUserByUsername(username);

        if (passwordEncoder.matches(password, userDetails.getPassword())) {
            return new UsernamePasswordAuthenticationToken(username, password, userDetails.getAuthorities());
        } else {
            throw new AuthenticationException("Invalid username or password") {};
        }
    }

    @Override
    public boolean supports(Class<?> authentication) {
        return UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication);
    }
}
```

### How It Works

1. **authenticate**:
   - Extracts the username and password from the `Authentication` object.
   - Loads the user details using the `UserDetailsService`.
   - Checks if the provided password matches the stored password using the `PasswordEncoder`.
   - If the passwords match, returns an authenticated `UsernamePasswordAuthenticationToken`.
   - If the passwords do not match, throws an `AuthenticationException`.

2. **supports**:
   - Checks if the `Authentication` object is of type `UsernamePasswordAuthenticationToken`.
   - Returns `true` if the authentication type is supported; otherwise, returns `false`.

### Integration with Spring Security

To integrate the custom `AuthenticationProvider` with Spring Security, you need to configure it in your security configuration class:

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    private final CustomAuthenticationProvider customAuthenticationProvider;

    public SecurityConfig(CustomAuthenticationProvider customAuthenticationProvider) {
        this.customAuthenticationProvider = customAuthenticationProvider;
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.authenticationProvider(customAuthenticationProvider);
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .anyRequest().authenticated()
                .and()
            .formLogin()
                .permitAll()
                .and()
            .logout()
                .permitAll();
    }
}
```

### Summary

The `AuthenticationProvider` interface in Spring Security provides a flexible way to implement various authentication mechanisms. By defining custom `AuthenticationProvider` implementations and configuring them in the security configuration, you can handle different authentication scenarios, such as username/password authentication, OAuth2 token authentication, and more.


The `DaoAuthenticationProvider` is a built-in implementation of the `AuthenticationProvider` interface in Spring Security, which is commonly used for username and password authentication. It interacts with a `UserDetailsService` to retrieve user information and uses a `PasswordEncoder` to verify the user's password.

### Key Components

1. **UserDetailsService**: A service interface that provides the method `loadUserByUsername(String username)` to retrieve user details.
2. **PasswordEncoder**: An interface used to encode and verify passwords.

### How `DaoAuthenticationProvider` Works

1. **Retrieving User Details**: The `DaoAuthenticationProvider` uses the `UserDetailsService` to load the user by username.
2. **Password Verification**: It uses a `PasswordEncoder` to compare the raw password provided during authentication with the encoded password stored in the user details.
3. **Returning Authentication**: If the password matches and the user is found, it returns an `Authentication` object with the user's authorities.

### Key Methods

#### authenticate

The `authenticate` method performs the authentication process.

```java
@Override
public Authentication authenticate(Authentication authentication) throws AuthenticationException {
    String username = (authentication.getPrincipal() == null) ? "NONE_PROVIDED" : authentication.getName();
    UserDetails user = this.getUserDetailsService().loadUserByUsername(username);
    if (user == null) {
        throw new UsernameNotFoundException("User not found");
    }

    if (!this.getPasswordEncoder().matches(authentication.getCredentials().toString(), user.getPassword())) {
        throw new BadCredentialsException("Bad credentials");
    }

    return new UsernamePasswordAuthenticationToken(user, authentication.getCredentials(), user.getAuthorities());
}
```

#### supports

The `supports` method checks if the `Authentication` type is `UsernamePasswordAuthenticationToken`.

```java
@Override
public boolean supports(Class<?> authentication) {
    return UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication);
}
```

### Example Configuration

Here is an example configuration of `DaoAuthenticationProvider` in a Spring Security application:

#### UserDetailsService Implementation

First, implement the `UserDetailsService` interface:

```java
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // Fetch user details from database or other source
        // Example hardcoded user
        if ("user".equals(username)) {
            return org.springframework.security.core.userdetails.User
                    .withUsername("user")
                    .password("$2a$10$Dow1q.QdG/O/Z4QJc5pYeO.z1nL5DPuYGV5jKoZL/HL3kI/q/nEYq") // password: "password" encoded with BCrypt
                    .authorities("ROLE_USER")
                    .build();
        } else {
            throw new UsernameNotFoundException("User not found");
        }
    }
}
```

#### Security Configuration

Next, configure the `DaoAuthenticationProvider` in the Spring Security configuration class:

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    private final UserDetailsService userDetailsService;

    public SecurityConfig(UserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.authenticationProvider(authenticationProvider());
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .anyRequest().authenticated()
                .and()
            .formLogin()
                .permitAll()
                .and()
            .logout()
                .permitAll();
    }

    @Override
    @Bean
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }
}
```

### How It Works

1. **UserDetailsService**: The custom `UserDetailsService` loads user details from a data source (e.g., database) or returns a hardcoded user for demonstration.
2. **PasswordEncoder**: The `BCryptPasswordEncoder` is used to encode and verify passwords.
3. **DaoAuthenticationProvider**: Configured with the `UserDetailsService` and `PasswordEncoder` to handle username/password authentication.
4. **AuthenticationManager**: Configured to use the `DaoAuthenticationProvider`.
5. **HttpSecurity**: Configures HTTP security to require authentication for all requests and provides form-based login and logout functionality.

### Summary

The `DaoAuthenticationProvider` in Spring Security is a powerful and flexible component for handling username and password authentication. By leveraging `UserDetailsService` to retrieve user details and `PasswordEncoder` to verify passwords, it provides a robust mechanism for authenticating users in a Spring Security application.


Authentication - 


The `Authentication` interface in Spring Security represents the result of an authentication process. It provides a way to encapsulate the user's authentication details and authorities (roles/permissions) within the Spring Security context.

### Key Features of the `Authentication` Interface

1. **Holds Authentication Details**: It contains information about the principal (the user), their credentials, and their authorities.
2. **Indicates Authentication Status**: It helps determine if a user has been successfully authenticated.
3. **Supports Various Authentication Scenarios**: It can be used for both successful and unsuccessful authentication attempts.

### Main Components of the `Authentication` Interface

#### Methods

1. **getPrincipal**
   - **Description**: Returns the principal (typically the username) that was used during the authentication process.
   - **Returns**: The principal object, often a `UserDetails` or a `String` (username).

   ```java
   Object getPrincipal();
   ```

2. **getCredentials**
   - **Description**: Returns the credentials (password or token) used in the authentication request.
   - **Returns**: The credentials object.

   ```java
   Object getCredentials();
   ```

3. **getAuthorities**
   - **Description**: Returns a collection of granted authorities (roles or permissions) assigned to the principal.
   - **Returns**: A collection of `GrantedAuthority` objects.

   ```java
   Collection<? extends GrantedAuthority> getAuthorities();
   ```

4. **isAuthenticated**
   - **Description**: Indicates whether the user has been authenticated successfully.
   - **Returns**: `true` if the user is authenticated; otherwise, `false`.

   ```java
   boolean isAuthenticated();
   ```

5. **setAuthenticated**
   - **Description**: Sets the authentication status. This is typically used internally to mark the authentication as successful or not.
   - **Parameters**: A boolean value indicating whether the user is authenticated.

   ```java
   void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;
   ```

6. **getDetails**
   - **Description**: Returns additional details about the authenticated user. This can include session details or any additional context.
   - **Returns**: An object containing details about the authentication.

   ```java
   Object getDetails();
   ```

### Implementations of `Authentication`

Spring Security provides several implementations of the `Authentication` interface:

1. **UsernamePasswordAuthenticationToken**
   - **Description**: Used for username and password authentication. It includes the username, password, and authorities.
   - **Example Usage**:

     ```java
     Authentication auth = new UsernamePasswordAuthenticationToken(
         username,
         password,
         authorities
     );
     ```

2. **JwtAuthenticationToken**
   - **Description**: Used for OAuth2 or JWT-based authentication. It includes the token and authorities.
   - **Example Usage**:

     ```java
     Authentication auth = new JwtAuthenticationToken(
         jwtToken,
         authorities
     );
     ```

3. **PreAuthenticatedAuthenticationToken**
   - **Description**: Used when authentication is performed outside of Spring Security (e.g., by an external system). It includes the principal and authorities.
   - **Example Usage**:

     ```java
     Authentication auth = new PreAuthenticatedAuthenticationToken(
         principal,
         credentials,
         authorities
     );
     ```

### Example Usage

Here is an example of how the `Authentication` interface is used in a Spring Security context:

#### Example of Creating an `Authentication` Object

```java
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.authority.SimpleGrantedAuthority;

import java.util.Collections;

public class AuthenticationExample {

    public static void main(String[] args) {
        // Create a token with username, password, and authorities
        Authentication auth = new UsernamePasswordAuthenticationToken(
            "user",
            "password",
            Collections.singleton(new SimpleGrantedAuthority("ROLE_USER"))
        );

        // Access authentication details
        String username = (String) auth.getPrincipal();
        String password = (String) auth.getCredentials();
        boolean isAuthenticated = auth.isAuthenticated();

        System.out.println("Username: " + username);
        System.out.println("Password: " + password);
        System.out.println("Authenticated: " + isAuthenticated);
    }
}
```

### How It Fits Into the Authentication Process

1. **Authentication Request**: When a user attempts to authenticate, an `Authentication` object is created with the provided credentials.
2. **Authentication Provider**: This object is passed to an `AuthenticationProvider` which validates the credentials and returns a populated `Authentication` object if authentication is successful.
3. **Security Context**: The `Authentication` object is then stored in the `SecurityContext` to be used for authorization decisions and to provide user details throughout the application.

### Summary

The `Authentication` interface in Spring Security plays a crucial role in the authentication process. It encapsulates the details of an authentication request, including the principal, credentials, authorities, and authentication status. Various implementations of this interface support different authentication mechanisms, such as username/password, OAuth2, and JWT. Understanding and using the `Authentication` interface allows for flexible and robust authentication handling in Spring Security applications.


Creating uuser defined AuthenticationProvider  -

create new class implementing AuthenticationProvider interface and implement all the methods - 


--------------

Elastic search 
Docker
Kubernetes
Spring Security
Kafka

DSA
revision

whatever new learned, revise it the same day.
5 DSA questions each day
Spring security- at least 3 videos
Apply for Jobs




----------------


विघ्नेश्वराय वरदाय सुरप्रियाय
लम्बोदराय सकलाय जगद्धिताय।
नागाननाय श्रुतियज्ञविभूषिताय
गौरीसुताय गणनाथ नमो नमस्ते।।

एकदन्ताय विबुधेश्वर पूजिताय
हेमांगदाय शुभदाय यथार्थनाय।
दूर्वादलाय जलजाय गणेश्वराय
सिद्धाय सिद्धिनाथ नमो नमस्ते।।

अखण्डिताय त्रिपुरान्तकवन्दनाय
सुमेरुसिन्धुपरिसर्यदवेन्दुभाय।
शार्दूलशोणवृषभाय भवात्मजाय
नागेश्वराय नयिनाथ नमो नमस्ते।।

विध्याविद्यारुपिणे सकलाय
काष्ठास्तम्भविभूषितधरण्यगाय।
बालार्कमंडलरथाय महारथाय
सुर्येश्वराय करुणाकर नमो नमस्ते।।

भक्तप्रणिपाताय वरदाय लोकाय
सुगन्धिगंधमधिपाय सुवामनाय।
सोमाय सोमवलभाय समस्ताय
सुरेश्वराय गणनाथ नमो नमस्ते।।

Explanation of the Full Stotra
Verse 1:

विघ्नेश्वराय वरदाय सुरप्रियाय
O Lord Vighneshwara, the giver of boons, beloved of the gods.
लम्बोदराय सकलाय जगद्धिताय
O the one with a large belly, the all-encompassing one, the well-wisher of the world.
नागाननाय श्रुतियज्ञविभूषिताय
O the one with the face of an elephant, adorned by Vedic rituals.
गौरीसुताय गणनाथ नमो नमस्ते
O the son of Gauri (Parvati), the lord of the Ganas, I bow to you.
Verse 2:

एकदन्ताय विबुधेश्वर पूजिताय
O one-tusked Lord, worshipped by the gods.
हेमांगदाय शुभदाय यथार्थनाय
O golden-bodied, the giver of auspiciousness and the embodiment of truth.
दूर्वादलाय जलजाय गणेश्वराय
O the one who is fond of durva grass, the lord of all Ganas.
सिद्धाय सिद्धिनाथ नमो नमस्ते
O the accomplished one, the lord of all accomplishments, I bow to you.
Verse 3:

अखण्डिताय त्रिपुरान्तकवन्दनाय
O the unbroken, worshipped by Tripurantaka (Shiva).
सुमेरुसिन्धुपरिसर्यदवेन्दुभाय
O the one whose glow rivals the Sun, Mount Meru, and the Moon.
शार्दूलशोणवृषभाय भवात्मजाय
O the one who rides on a lion or a bull, the son of Bhava (Shiva).
नागेश्वराय नयिनाथ नमो नमस्ते
O the lord of serpents, the master of the eyes, I bow to you.
Verse 4:

विध्याविद्यारुपिणे सकलाय
O the embodiment of all knowledge and education.
काष्ठास्तम्भविभूषितधरण्यगाय
O the one who supports the earth like a pillar.
बालार्कमंडलरथाय महारथाय
O the one who rides a chariot like the infant Sun.
सुर्येश्वराय करुणाकर नमो नमस्ते
O the lord of the Sun, the compassionate one, I bow to you.
Verse 5:

भक्तप्रणिपाताय वरदाय लोकाय
O the one who receives the obeisance of devotees, the giver of boons to the world.
सुगन्धिगंधमधिपाय सुवामनाय
O the one who is fragrant like flowers and sandalwood.
सोमाय सोमवलभाय समस्ताय
O the one who is like the moon, loved by all, encompassing all.
सुरेश्वराय गणनाथ नमो नमस्ते
O the lord of the Ganas, the lord of the gods, I bow to you.


2) 


गणनायकाय गणदैवताय
गणाध्यक्षाय धीमहि।
गुणशरीराय गुणमण्डिताय
गुणेशानाय धीमहि।
गुणातीताय गुणाधीशाय
गुणप्रविष्टाय धीमहि।।

एकदन्ताय वक्रतुण्डाय
गौरीतनयाय धीमहि।
गजेशानाय भालचन्द्राय
श्रीगणेशाय धीमहि।।

गणचतुराय गणप्राणाय
गणान्तरात्मने।
गानोत्सुखाय गानमत्ताय
गणोत्त्सुखमनोऽसे।।
गुरुपूजिताय गुरुदेवताय
गुरुकुलस्थायिने।
गुरुविक्रमाय गुह्यप्रवराय
गुरवे गुणगुरवे।।
गुरुदैत्यकालक्षेत्रे
गुरुसारसाराराध्याय।
गुरुपुत्रपरित्रात्रे
गुरुपाखण्डखण्डकाय।।

गीतसाराय गीततत्त्वाय
गीतगोत्राय धीमहि।
गूढगुल्फाय गन्धमत्ताय
गोयज्ञप्रदाय धीमहि।।
गुणातीताय गुणाधीशाय
गुणप्रविष्टाय धीमहि।।

एकदन्ताय वक्रतुण्डाय
गौरीतनयाय धीमहि।
गजेशानाय भालचन्द्राय
श्रीगणेशाय धीमहि।।

गन्धर्वराजाय गन्धाय
गन्धर्वगणश्रवणप्रणामे।
गाढानुरागाय ग्रन्थाय
गीताय ग्रन्थार्थतन्मये।।
गुरिलीगुणवते गणपतये।।

ग्रन्थगीताय ग्रन्थगेयाय
ग्रन्थतारात्मने।
गीतलीनाय गीताश्रयाय
गीतवाद्यपतवे।
ध्येयचरिताय गायकवराय
गन्धर्वप्रिक्रुपे।
गायकाधीनविग्रहाय
गंगाजलप्रणायवते।
गौरिस्थानमाधाय गौरिहृदय
नन्दनाय।
गौरभानुसुताय गौरी
गणेश्वराय।।

गौरिप्रणाय गौरिप्रवणाय
गौरभावाय धीमहि।
ओसहस्राय गोवर्धनाय
गोपगोपालाय धीमहि।।
गुणातीताय गुणाधीशाय
गुणप्रविष्टाय धीमहि।।

एकदन्ताय वक्रतुण्डाय
गौरीतनयाय धीमहि।
गजेशानाय भालचन्द्राय
श्रीगणेशाय धीमहि।।


Verse 1
गणनायकाय गणदैवताय गणाध्यक्षाय धीमहि।
We meditate on the leader of the Ganas, the deity of the Ganas, and the chief of the Ganas.

गुणशरीराय गुणमण्डिताय गुणेशानाय धीमहि।
We meditate on the one who embodies virtues, who is adorned with virtues, and who is the lord of virtues.

गुणातीताय गुणाधीशाय गुणप्रविष्टाय धीमहि।
We meditate on the one who transcends qualities, who is the master of qualities, and who is the essence of all qualities.

Verse 2
एकदन्ताय वक्रतुण्डाय गौरीतनयाय धीमहि।
We meditate on the one-tusked, curved-trunked Lord, the son of Goddess Gauri (Parvati).

गजेशानाय भालचन्द्राय श्रीगणेशाय धीमहि।
We meditate on the elephant-faced lord, who has the crescent moon on his forehead, and who is Shri Ganesha.

Verse 3
गणचतुराय गणप्राणाय गणान्तरात्मने।
We meditate on the wise and clever leader of the Ganas, the life force of the Ganas, and the one who resides within the Ganas.

गानोत्सुखाय गानमत्ताय गणोत्त्सुखमनोऽसे।
We meditate on the one who is eager to hear songs, who is intoxicated with the joy of music, and who brings joy to the minds of those who sing.

गुरुपूजिताय गुरुदेवताय गुरुकुलस्थायिने।
We meditate on the one who is worshipped by gurus, who is the deity of the gurus, and who resides in the guru's abode.

गुरुविक्रमाय गुह्यप्रवराय गुरवे गुणगुरवे।
We meditate on the one who is mighty among the gurus, who is the best among the secret deities, and who is the guru of all virtues.

गुरुदैत्यकालक्षेत्रे गुरुसारसाराराध्याय।
We meditate on the one who is the destroyer of demons, who is worshipped by the essence of the best sages.

गुरुपुत्रपरित्रात्रे गुरुपाखण्डखण्डकाय।
We meditate on the one who is the protector of the guru's sons and who destroys hypocrisy.

Verse 4
गीतसाराय गीततत्त्वाय गीतगोत्राय धीमहि।
We meditate on the essence of the songs, the true meaning of the songs, and the one who belongs to the lineage of music.

गूढगुल्फाय गन्धमत्ताय गोयज्ञप्रदाय धीमहि।
We meditate on the one who has hidden ankles, who is intoxicated with fragrance, and who grants the fruits of the cow-sacrifice.

गुणातीताय गुणाधीशाय गुणप्रविष्टाय धीमहि।
We meditate on the one who transcends qualities, who is the master of qualities, and who is the essence of all qualities.

Verse 5
एकदन्ताय वक्रतुण्डाय गौरीतनयाय धीमहि।
We meditate on the one-tusked, curved-trunked Lord, the son of Goddess Gauri (Parvati).

गजेशानाय भालचन्द्राय श्रीगणेशाय धीमहि।
We meditate on the elephant-faced lord, who has the crescent moon on his forehead, and who is Shri Ganesha.

Verse 6
गन्धर्वराजाय गन्धाय गन्धर्वगणश्रवणप्रणामे।
We meditate on the king of the Gandharvas, who is fragrant, and who is saluted by the Gandharva tribes.

गाढानुरागाय ग्रन्थाय गीताय ग्रन्थार्थतन्मये।
We meditate on the one who is deeply attached to love, who is the essence of scriptures and songs, and who is immersed in their meaning.

गुरिलीगुणवते गणपतये।
We meditate on the one who is rich in virtues and is the lord of the Ganas.

Verse 7
ग्रन्थगीताय ग्रन्थगेयाय ग्रन्थतारात्मने।
We meditate on the one who is the song of scriptures, who is sung in scriptures, and who is the essence of scriptures.

गीतलीनाय गीताश्रयाय गीतवाद्यपतवे।
We meditate on the one who is absorbed in music, who takes refuge in songs, and who is the master of musical instruments.

ध्येयचरिताय गायकवराय गन्धर्वप्रिक्रुपे।
We meditate on the one who has an exemplary character, who is the best among singers, and who is the companion of the Gandharvas.

गायकाधीनविग्रहाय गंगाजलप्रणायवते।
We meditate on the one whose form is subject to singers, and who has a deep love for the waters of the Ganges.

गौरिस्थानमाधाय गौरिहृदय नन्दनाय।
We meditate on the one who dwells in Gauri's abode and who is the joy of Gauri's heart.

गौरभानुसुताय गौरी गणेश्वराय।
We meditate on the son of Gauri, the lord of Gauri's Ganas.

Verse 8
गौरिप्रणाय गौरिप्रवणाय गौरभावाय धीमहि।
We meditate on the one who is devoted to Gauri, who is inclined towards Gauri, and who embodies Gauri's feelings.

ओसहस्राय गोवर्धनाय गोपगोपालाय धीमहि।
We meditate on the one who has thousands of cows, who is the lifter of Govardhan, and who is the protector of cows and cowherds.

गुणातीताय गुणाधीशाय गुणप्रविष्टाय धीमहि।
We meditate on the one who transcends qualities, who is the master of qualities, and who is the essence of all qualities.

Verse 9
एकदन्ताय वक्रतुण्डाय गौरीतनयाय धीमहि।
We meditate on the one-tusked, curved-trunked Lord, the son of Goddess Gauri (Parvati).

गजेशानाय भालचन्द्राय श्रीगणेशाय धीमहि।
We meditate on the elephant-faced lord, who has the crescent moon on his forehead, and who is Shri Ganesha.

------------

concepts to look after recursion - 

Backtracking


----------


Assignemnt - 

Cascade
Passimistic lock 

-----------

Multithreading - 

----------
learn how to generate all the subset of an array by using power set method check strivers channel for this.



------------

Round robin - 

The **Round Robin (RR)** algorithm is one of the simplest and most widely used CPU scheduling algorithms in operating systems. It is designed primarily for time-sharing systems, where each process gets a small unit of CPU time in a cyclic order.

### How Round Robin Works:

1. **Time Quantum:** The key concept in Round Robin scheduling is the time quantum (or time slice). This is a fixed amount of time that each process is allowed to run before it is preempted (i.e., interrupted) and placed at the back of the ready queue.

2. **Ready Queue:** The processes are stored in a ready queue, which is typically implemented as a First-In-First-Out (FIFO) queue.

3. **Process Execution:**
   - The CPU scheduler picks the first process from the ready queue and assigns the CPU to it for one time quantum.
   - If the process completes within the time quantum, it leaves the system or moves to a waiting state (if it requires I/O).
   - If the process does not complete, it is preempted after the time quantum expires and placed at the back of the ready queue.

4. **Cyclic Order:** The scheduler then picks the next process in the queue, and the cycle continues until all processes are complete.

### Example:

Consider three processes: P1, P2, and P3 with burst times of 5, 9, and 6 units, respectively. Assume a time quantum of 3 units.

1. **Initial Queue:** P1 (5), P2 (9), P3 (6)
2. **First Cycle:** 
   - P1 executes for 3 units, 2 units remain. (Queue: P2, P3, P1)
   - P2 executes for 3 units, 6 units remain. (Queue: P3, P1, P2)
   - P3 executes for 3 units, 3 units remain. (Queue: P1, P2, P3)
3. **Second Cycle:**
   - P1 executes for 2 units and completes. (Queue: P2, P3)
   - P2 executes for 3 units, 3 units remain. (Queue: P3, P2)
   - P3 executes for 3 units and completes. (Queue: P2)
4. **Final Cycle:**
   - P2 executes for 3 units and completes.

### Characteristics of Round Robin:

- **Fairness:** Every process gets an equal share of the CPU time, ensuring that no process is starved.
- **Responsiveness:** Suitable for time-sharing systems where quick response times are important.
- **Context Switching:** The frequent switching between processes can lead to higher context-switching overhead, especially if the time quantum is too small.

### Time Quantum Selection:

- **Too Large:** If the time quantum is too large, Round Robin behaves like First-Come-First-Served (FCFS), and short processes may have to wait for long processes to complete.
- **Too Small:** If the time quantum is too small, the overhead of context switching can become significant, degrading system performance.

### Advantages:

- Simple to implement.
- Provides a good balance between fairness and response time.

### Disadvantages:

- High context switching overhead if the time quantum is not well-tuned.
- Not ideal for real-time systems where specific timing requirements are critical.

Round Robin is an effective algorithm in environments where a balanced CPU time distribution is needed among all processes, making it popular in general-purpose time-sharing systems.


------------

Two phase commit - 

The **Two-Phase Commit (2PC)** protocol is a distributed algorithm used to ensure atomicity in transactions across multiple servers (also known as participants or nodes) in a distributed database system. It ensures that a distributed transaction either commits (i.e., all servers commit the changes) or aborts (i.e., none of the servers apply any changes) in a consistent manner.

### Context: Database with Different Servers
Imagine a distributed database where data is spread across several servers, each potentially holding different parts of the data (e.g., one server might handle customer data, another might handle product data). When a transaction involves updates to multiple servers (such as updating a customer's address on one server and updating an order status on another), it's crucial that either **all** updates happen or **none** happen. This is where the 2PC protocol comes into play.

### Phases of the Two-Phase Commit Protocol
The 2PC protocol has two phases:

#### 1. **Phase 1: The Prepare (or Voting) Phase**
In this phase, a **coordinator** (typically the server initiating the transaction) sends a "prepare" request to all participating servers (or cohorts) involved in the transaction, asking them if they are ready to commit the transaction. Each server can respond in one of two ways:
   - **Vote to Commit**: If the server has executed the transaction successfully and can commit the changes, it responds with a "Yes".
   - **Vote to Abort**: If the server encounters an issue (such as failure to execute the transaction, conflicts, or unavailability of resources), it responds with a "No".

Steps:
1. The coordinator sends a `Prepare` message to all participating servers.
2. Each server attempts to execute the transaction locally, without committing it yet. If successful, they write the transaction to a log and reply `Yes` (vote to commit); otherwise, they reply `No` (vote to abort).

At the end of Phase 1, the coordinator collects the votes from all servers:
- If **all** servers vote to commit, the coordinator proceeds to Phase 2 (Commit).
- If **any one** server votes to abort, the coordinator proceeds to Phase 2 (Abort).

#### 2. **Phase 2: The Commit (or Abort) Phase**
Based on the votes gathered in Phase 1, the coordinator takes one of the following actions:
   - **Commit**: If all servers voted "Yes" in the prepare phase, the coordinator sends a `Commit` message to all servers, instructing them to permanently commit the transaction.
   - **Abort**: If even one server voted "No", the coordinator sends an `Abort` message, instructing all servers to roll back (undo) any changes made during the prepare phase.

Steps:
1. If all servers voted "Yes", the coordinator sends a `Commit` message to all participants.
2. If any server voted "No", the coordinator sends an `Abort` message to all participants.
3. Upon receiving a `Commit` or `Abort` message, each server either commits or rolls back the transaction and sends an acknowledgment back to the coordinator.
4. The coordinator logs the outcome (commit or abort) and notifies the clients of the final status.

### Example Scenario
Consider a scenario where a distributed transaction updates two servers:
- **Server 1**: Manages customer data.
- **Server 2**: Manages order data.

A transaction requests an update to both a customer’s address (Server 1) and the status of their order (Server 2). Here's how 2PC would ensure consistency:

1. **Phase 1: Prepare**:
   - The coordinator asks both Server 1 and Server 2 if they are ready to commit.
   - Server 1 successfully updates the address and votes "Yes".
   - Server 2 encounters a resource issue and votes "No".
   
2. **Phase 2: Commit/Abort**:
   - Since Server 2 voted "No", the coordinator sends an `Abort` message to both servers.
   - Server 1 rolls back the address update.
   - The transaction is aborted.

### Key Features and Guarantees
- **Atomicity**: Either all servers commit or none do. No partial commits are allowed.
- **Consistency**: If the transaction commits, the system reaches a consistent state across all servers.
- **Durability**: Once a transaction is committed, it is durable (i.e., it survives system failures due to logging mechanisms).

### Drawbacks of 2PC
While 2PC ensures atomicity and consistency in distributed transactions, it has some disadvantages:
1. **Blocking**: If the coordinator crashes after sending the `Prepare` message but before sending a `Commit` or `Abort`, the participants may be left in an uncertain state, waiting indefinitely for instructions.
2. **Single Point of Failure**: The coordinator is critical to the protocol. If the coordinator fails, recovery mechanisms are complex.
3. **Performance**: 2PC introduces delays since participants must wait for instructions from the coordinator before committing or aborting.

To mitigate these issues, advanced protocols such as **Three-Phase Commit (3PC)** or other consensus-based algorithms (like **Paxos** or **Raft**) are sometimes used in distributed systems.

-----------

Dynamic Programming - 

-------------
 

of - gives the value of an array.
in - gives us the key of the object.

--------

String methods - 

isEmpty
compareTo
compareIgnoreCase
replace
string format




If you use the code `String.format("%s %s %s", "a", "b");`, it will throw a `MissingFormatArgumentException`. This is because there are three `%s` placeholders in the format string, but only two arguments are provided. 

The exception message will be:

```
java.util.MissingFormatArgumentException: Format specifier '%s'
```

This indicates that one of the `%s` placeholders is missing a corresponding argument, specifically the third one in this case.


Q - MessageFormat.format("{0} {1} {0}", "a")  - 

The MessageFormat.format method expects an array of arguments that correspond to the placeholders {0}, {1}, etc., in the format string. In your example, you’ve provided three placeholders but only one argument, "a".

Here’s what happens:

{0} will be replaced by the first argument "a".
{1} does not have a corresponding argument, so it will throw an IllegalArgumentException due to a missing argument for that placeholder.


Q - | operator

	and difference between | and || operators

Q - Jump statements - 

In Java, **jump statements** are used to transfer control to other parts of the program. There are three primary jump statements:

### 1. `break` Statement
- **Purpose**: Exits the current loop (`for`, `while`, or `do-while`) or a `switch` statement.
- **Usage**: Commonly used to terminate a loop based on a condition or exit a `switch` case.
  
  ```java
  for (int i = 0; i < 10; i++) {
      if (i == 5) {
          break; // Exits the loop when i equals 5
      }
      System.out.println(i);
  }
  ```

### 2. `continue` Statement
- **Purpose**: Skips the current iteration of a loop and proceeds to the next iteration.
- **Usage**: Often used to skip certain iterations based on a condition.
  
  ```java
  for (int i = 0; i < 10; i++) {
      if (i % 2 == 0) {
          continue; // Skips the rest of the loop body for even numbers
      }
      System.out.println(i); // Only odd numbers are printed
  }
  ```

### 3. `return` Statement
- **Purpose**: Exits from the current method and optionally returns a value.
- **Usage**: Used to exit a method and optionally pass a value back to the caller.
  
  ```java
  public int sum(int a, int b) {
      return a + b; // Returns the result and exits the method
  }
  ```

### 4. `label` Statement (with `break` and `continue`)
- **Purpose**: Allows `break` and `continue` to be applied to outer loops (for nested loops).
- **Usage**: You can label loops and use `break` or `continue` with the label to specify which loop to jump out of.

  ```java
  outerLoop:
  for (int i = 0; i < 5; i++) {
      for (int j = 0; j < 5; j++) {
          if (i == 2 && j == 2) {
              break outerLoop; // Exits the outer loop when i == 2 and j == 2
          }
          System.out.println(i + ", " + j);
      }
  }
  ```

Each of these jump statements provides a different way to control the flow of execution, making it easier to manage loops and methods effectively in Java.

In Java, **labels** are used to identify loops and are particularly useful when working with nested loops. They allow you to control which loop you want to affect when using `break` or `continue` statements. By labeling a loop, you can specify that you want to break out of or continue the labeled loop instead of just the innermost one.

### How to Use Labels
- A label is an identifier followed by a colon (`:`) placed right before a loop (`for`, `while`, or `do-while`).
- You can then use `break` or `continue` with the label name to affect that specific loop.

### Syntax
```java
labelName:
for (int i = 0; i < 5; i++) {
    for (int j = 0; j < 5; j++) {
        if (/* some condition */) {
            break labelName; // Exits the labeled loop
        }
        if (/* another condition */) {
            continue labelName; // Skips to the next iteration of the labeled loop
        }
    }
}
```

### Example with `break`
The `break` statement, when used with a label, allows you to exit out of a specific loop, even if it is nested within other loops. 

```java
outerLoop:
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (i == 1 && j == 1) {
            break outerLoop; // Exits the outer loop when i == 1 and j == 1
        }
        System.out.println("i = " + i + ", j = " + j);
    }
}
```

Output:
```
i = 0, j = 0
i = 0, j = 1
i = 0, j = 2
i = 1, j = 0
```
In this example, when `i == 1` and `j == 1`, the `break outerLoop` statement is triggered, which exits the entire `outerLoop` instead of just the inner loop.

### Example with `continue`
The `continue` statement, when used with a label, skips the current iteration of the specified labeled loop and proceeds with the next iteration of that loop.

```java
outerLoop:
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (i == 1 && j == 1) {
            continue outerLoop; // Skips to the next iteration of the outer loop
        }
        System.out.println("i = " + i + ", j = " + j);
    }
}
```

Output:
```
i = 0, j = 0
i = 0, j = 1
i = 0, j = 2
i = 1, j = 0
i = 2, j = 0
i = 2, j = 1
i = 2, j = 2
```
Here, when `i == 1` and `j == 1`, `continue outerLoop` skips the rest of the inner loop and moves directly to the next iteration of `outerLoop`, so `j = 1` and `j = 2` for `i = 1` are not printed.

### When to Use Labels
Labels should be used sparingly as they can make code harder to read, especially in deeply nested loops. Labels are helpful when:
- You have nested loops and need to break out of or continue a loop that is not the innermost one.
- You want to avoid complex logic or flags for loop control.

Using labels can make your control flow more straightforward in these cases, but overuse can lead to confusing code, so they should be used only when necessary.


Q -    @Koan
    public void bytesHaveASmallerRangeThanShorts() {
        assertEquals(Byte.MIN_VALUE, );
        assertEquals(Byte.MAX_VALUE, __);

        // Why would you use short or byte considering that you need to do explicit
        // casts?
    }

what is the meaning of the commented lines here

ChatGPT said:
ChatGPT
The commented lines are prompting you to consider the scenarios where you would use byte or short instead of the default int type in Java, especially given the need for explicit casts when working with smaller data types.

Here’s a breakdown of the two key points:

Explicit Casting:

Since byte and short have smaller ranges compared to int, using them often involves explicit casting, especially when performing arithmetic operations.
For example, if you add two byte values, Java automatically promotes them to int, so you need to cast the result back to byte if you want to store it as a byte.
This can be cumbersome, which is why int is generally preferred for arithmetic, even if you don't need the full range.
Why Use byte or short?:

Memory Efficiency: byte (8 bits) and short (16 bits) consume less memory compared to int (32 bits). For large arrays or data structures with many numbers, using byte or short can save significant memory.
Performance: In some cases, using smaller data types can improve performance, especially in low-level programming, embedded systems, or when interfacing with hardware where data size matters.
Specific Requirements: Certain protocols, file formats, or APIs may require data to be in specific formats or sizes. For example, binary data streams or network packets might specify the use of byte for certain fields.

So, the comment is encouraging you to think about when it might be worth using short or byte, even though doing so can involve extra effort due to explicit casting.


Q - In Java, both `1.0e3` and `1E3` are representations of floating-point numbers in scientific notation. They are equivalent and represent the same numerical value. Here’s a breakdown of each representation:

### Scientific Notation
- **Format**: In scientific notation, a number is expressed in the form of \( m \times 10^n \), where:
  - \( m \) is the mantissa (the significant digits).
  - \( n \) is the exponent (the power of 10).
  
### Explanation of the Numbers

1. **`1.0e3`**
   - **Interpretation**: 
     - `1.0` is the mantissa.
     - `e3` indicates that the mantissa should be multiplied by \( 10^3 \).
   - **Value**: 
     - \( 1.0 \times 10^3 = 1.0 \times 1000 = 1000.0 \)
   - **Type**: In Java, this value is treated as a `double` by default because it contains a decimal point.

2. **`1E3`**
   - **Interpretation**: 
     - `1` is the mantissa.
     - `E3` indicates that the mantissa should be multiplied by \( 10^3 \).
   - **Value**: 
     - \( 1 \times 10^3 = 1 \times 1000 = 1000.0 \)
   - **Type**: This value is also treated as a `double` in Java by default.

### Summary
- Both `1.0e3` and `1E3` represent the same numerical value, which is `1000.0`.
- Both are treated as `double` type in Java, allowing for precision in floating-point calculations.

### Example in Java
You can see this in action with a simple Java program:

```java
public class Main {
    public static void main(String[] args) {
        double num1 = 1.0e3;
        double num2 = 1E3;

        System.out.println(num1); // Output: 1000.0
        System.out.println(num2); // Output: 1000.0
    }
}
```

This program will output `1000.0` for both representations, demonstrating their equivalence in value.


Overriding the `toString()` method in Java is considered a best practice for several reasons. Here are the key benefits:

### 1. **Improved Readability**
- The default implementation of `toString()` (inherited from the `Object` class) returns a string that consists of the class name followed by the "@" character and the object's hash code in hexadecimal form (e.g., `ClassName@1a2b3c`). This is not informative and does not provide meaningful information about the object's state.
- By overriding `toString()`, you can provide a human-readable string that summarizes the object's state, making it easier to understand when printed.

### 2. **Debugging Convenience**
- When debugging, having a meaningful string representation of an object can be invaluable. If you print the object to the console or log it, an overridden `toString()` method will provide useful context about the object's current state, which can help in diagnosing issues.

### 3. **Ease of Logging**
- Logging frameworks often use the `toString()` method to display the state of objects. By overriding it, you can control the output and ensure that the logged information is relevant and useful.

### 4. **Consistent String Representation**
- In complex systems, especially those using collections, having a consistent and meaningful string representation of your objects can help when printing lists or arrays of objects. It ensures that each object's output is understandable and consistent with its intended representation.

### 5. **Enhancing API Usability**
- If you are designing a public API, overriding `toString()` provides users of your API with a better understanding of your classes. It allows users to quickly see what an object represents without needing to access each field individually.

### Example of Overriding `toString()`

Here’s a simple example of how to override the `toString()` method in a custom class:

```java
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + "}";
    }
}

public class Main {
    public static void main(String[] args) {
        Person person = new Person("Alice", 30);
        System.out.println(person); // Output: Person{name='Alice', age=30}
    }
}
```

### Summary
Overriding the `toString()` method:
- Enhances the readability and usability of objects.
- Aids in debugging and logging.
- Provides a consistent and meaningful representation of objects, making your code easier to understand and maintain.

For these reasons, it is recommended to override the `toString()` method in your Java classes when appropriate.


Q - what the hell is happening in below

   @Koan
    public void objectToString() {
        Object object = new Object();
        // TODO: Why is it best practice to ALWAYS override toString?
        String expectedToString = MessageFormat.format("{0}@{1}", Object.class.getName(),
                Integer.toHexString(object.hashCode()));
        assertEquals(expectedToString, __); // hint: object.toString()
    }
ChatGPT said:
ChatGPT
The code you provided appears to be part of a test case (likely using a testing framework such as JUnit or a custom framework) designed to illustrate the importance of overriding the toString() method in Java. Let’s break down what's happening in the method:

Code Breakdown
Object Creation:

java
Copy code
Object object = new Object();
An instance of Object is created. The Object class is the root of the class hierarchy in Java.
Expected String Representation:

java
Copy code
String expectedToString = MessageFormat.format("{0}@{1}", Object.class.getName(), Integer.toHexString(object.hashCode()));
Here, expectedToString is being created using MessageFormat.format(). It constructs a string in the format:
less
Copy code
[ClassName]@[HashCode]
Object.class.getName() returns the name of the Object class (i.e., "java.lang.Object").
Integer.toHexString(object.hashCode()) computes the hash code of the object instance and converts it to a hexadecimal string.
The resulting format for the object created above might look something like this:
css
Copy code
java.lang.Object@1a2b3c
This string represents the default behavior of the toString() method in Java, which does not provide any meaningful information about the object's state.
Assertion:

java
Copy code
assertEquals(expectedToString, __); // hint: object.toString()
The assertEquals() method is used to compare expectedToString with another value (represented by the placeholder __).
The hint object.toString() suggests that you should call the toString() method on the object instance to retrieve its string representation.
However, because Object does not override toString(), it will return the default implementation, which produces the output similar to what expectedToString generates.
Why is it Best Practice to Override toString()?
The comments in the code indicate the underlying lesson: why it's best practice to always override the toString() method. Here’s why:

Default Behavior is Uninformative:

The default toString() implementation does not provide useful information about the object's state. For most classes, it just gives the class name and the hash code, which is not helpful for debugging or logging.
Custom Representation:

By overriding toString(), you can provide a meaningful string representation that includes relevant information about the object's attributes and state, improving readability and maintainability.
Conclusion
This test is designed to highlight the inadequacy of the default toString() method implementation and the importance of overriding it in your classes. The intention is to encourage developers to think about how their objects are represented as strings, especially when it comes to debugging, logging, and displaying object information.

If you complete the test by overriding the toString() method in a custom class and returning a meaningful representation, the assertion will pass and reinforce the lesson that you should provide a custom implementation of toString() in your classes.


Q - toString in detail - 

In Java, the `toString()` method is a fundamental method defined in the `Object` class, which is the superclass of all classes in Java. This method is intended to provide a string representation of an object, and it can be overridden in custom classes to produce meaningful and informative output. Here's a detailed explanation of how the `toString()` method works, including its default behavior and how to override it in a class.

### Default Behavior

1. **Inheritance from `Object`**: 
   - Every class in Java inherits from the `Object` class, which means they also inherit the `toString()` method.

2. **Default Implementation**:
   - The default implementation of `toString()` in the `Object` class returns a string that consists of:
     - The class name (including the package name).
     - The "@" character.
     - The object's hash code in hexadecimal format.

   ```java
   @Override
   public String toString() {
       return getClass().getName() + "@" + Integer.toHexString(hashCode());
   }
   ```

   For example, if you create an instance of a class that does not override `toString()`, calling `toString()` on that instance might return something like this:
   ```
   com.example.MyClass@1a2b3c
   ```

### Customizing `toString()`

To provide a more meaningful representation of an object, you can override the `toString()` method in your class. Here's how to do it:

1. **Defining the Class**:
   - Create a class with some fields that you want to represent in the string.

2. **Overriding `toString()`**:
   - Override the `toString()` method to return a string that summarizes the important information about the object.

### Example

Here’s an example of a custom class with an overridden `toString()` method:

```java
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Override toString() method
    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + "}";
    }
}

public class Main {
    public static void main(String[] args) {
        Person person = new Person("Alice", 30);
        System.out.println(person.toString()); // Output: Person{name='Alice', age=30}
        System.out.println(person); // Output: Person{name='Alice', age=30}
    }
}
```

### Explanation of the Example

- **Class Definition**:
  - The `Person` class has two fields: `name` and `age`.

- **Constructor**:
  - The constructor initializes the `name` and `age` fields.

- **Overriding `toString()`**:
  - The `toString()` method is overridden to return a string in a human-readable format, summarizing the object's state.

- **Using `toString()`**:
  - In the `Main` class, when you create an instance of `Person` and print it, either by explicitly calling `toString()` or just using `System.out.println()`, the overridden method is invoked.

### Benefits of Overriding `toString()`

1. **Improved Readability**: The overridden `toString()` method provides a clear and concise representation of the object, which is useful for debugging and logging.

2. **Consistency**: When printing collections of objects or working with APIs, having a meaningful string representation makes the output more understandable.

3. **Customization**: You can tailor the output to include the most relevant fields and format it in a way that makes sense for your application.

### Conclusion

The `toString()` method is a powerful and flexible tool in Java that allows you to define how your objects are represented as strings. By overriding it in your classes, you can provide meaningful insights into the state of your objects, enhancing the readability and maintainability of your code.

Q - Type casting in java - 


Type casting in Java is the process of converting a variable from one type to another. It is particularly useful when working with objects, numbers, and different data types. There are two main types of type casting in Java: **implicit (automatic) casting** and **explicit (manual) casting**. 

### 1. Implicit Casting (Widening Conversion)

Implicit casting occurs when a smaller data type is converted to a larger data type automatically by the Java compiler. This is safe because there is no risk of data loss.

**Example**:
```java
int intValue = 100; // 4 bytes
long longValue = intValue; // Implicit casting from int to long
double doubleValue = longValue; // Implicit casting from long to double
```

In this example:
- An `int` (4 bytes) is automatically converted to a `long` (8 bytes).
- A `long` is automatically converted to a `double` (8 bytes).

### 2. Explicit Casting (Narrowing Conversion)

Explicit casting occurs when a larger data type is converted to a smaller data type. This must be done manually, as there is a risk of data loss when narrowing the type.

**Example**:
```java
double doubleValue = 100.99; // 8 bytes
int intValue = (int) doubleValue; // Explicit casting from double to int
```

In this example:
- The `double` value is explicitly cast to an `int`. This will result in the loss of the decimal part, and `intValue` will be `100`.

### 3. Object Type Casting

In addition to primitive data types, type casting also applies to objects. Java allows for casting between related classes in the inheritance hierarchy.

#### a. Upcasting

Upcasting is casting a subclass reference to a superclass reference. This is always safe and does not require an explicit cast.

**Example**:
```java
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    void sound() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Dog(); // Upcasting
        animal.sound(); // Output: Dog barks
    }
}
```

In this example:
- A `Dog` object is upcast to an `Animal` reference. This is safe because `Dog` is a subclass of `Animal`.

#### b. Downcasting

Downcasting is casting a superclass reference back to a subclass reference. This requires an explicit cast and can lead to a `ClassCastException` at runtime if the object is not of the target subclass type.

**Example**:
```java
Animal animal = new Dog(); // Upcasting
Dog dog = (Dog) animal; // Downcasting
dog.sound(); // Output: Dog barks
```

In this example:
- The `animal` reference is downcast to a `Dog`. This is safe here because `animal` refers to a `Dog` object.

However, if you try to downcast an `Animal` that is not a `Dog`, you'll get a `ClassCastException`:

```java
Animal animal = new Animal(); // This is not a Dog
Dog dog = (Dog) animal; // This will throw ClassCastException at runtime
```

### Summary of Type Casting in Java

- **Implicit Casting**:
  - Automatically performed by the compiler.
  - Safe and no data loss.
  - Examples include converting `int` to `long` or `float` to `double`.

- **Explicit Casting**:
  - Must be performed manually using parentheses.
  - Risk of data loss.
  - Examples include converting `double` to `int`.

- **Object Type Casting**:
  - **Upcasting**: Safe and automatic when moving from subclass to superclass.
  - **Downcasting**: Requires an explicit cast and can cause runtime exceptions if not done carefully.

Type casting is an important concept in Java that helps manage different data types and ensures that variables are of the correct type when performing operations. Proper use of type casting can enhance code flexibility and maintainability.


Q - When you force a `long` value into an `int` in Java, you are performing a **narrowing conversion** because `long` (64-bit) is larger than `int` (32-bit). This requires an **explicit cast**, as there is potential for **data loss** if the `long` value is too large to fit into the range of an `int`.

### How it Works
To cast a `long` to an `int`, you must explicitly cast it using `(int)`. During this cast, Java truncates the higher 32 bits, which may lead to a **loss of information** if the `long` value exceeds the range of an `int`.

### Example
```java
long longValue = 12345678901234L;
int intValue = (int) longValue; // Explicit casting

System.out.println("Original long value: " + longValue);
System.out.println("Casted int value: " + intValue);
```

### Output Explanation
If you run this code with a `long` value that exceeds the `int` range (i.e., if it is greater than `2,147,483,647` or less than `-2,147,483,648`), the `intValue` will not hold the original `long` value. Instead, it will wrap around and produce an **unexpected** value due to overflow.

For example, given `longValue = 12345678901234L`, the output might look like this:
```
Original long value: 12345678901234
Casted int value: -1942892530
```

### Explanation of Overflow
In this example, since `12345678901234L` exceeds the range of an `int`, the bits are truncated, resulting in a negative `int` value. This occurs because Java only keeps the lower 32 bits when casting to an `int`, and the original `long` value’s upper bits are lost.

### Safe Casting Scenarios
If the `long` value is within the `int` range, casting will be safe, and the resulting `int` value will accurately reflect the original `long` value:
```java
long smallLong = 12345L; // Within int range
int smallInt = (int) smallLong;
System.out.println(smallInt); // Output: 12345
```

### Conclusion
Casting a `long` to an `int` can lead to overflow if the `long` value exceeds the `int` range. It is important to ensure that the `long` value fits within the `int` range before casting or handle the possible overflow outcome appropriately.


Q - When you force a `long` value into an `int`, as in your example:

```java
long a = 2147483648L; // This value is beyond the int range
int b = (int) a; // Explicit casting from long to int
```

you are performing a narrowing conversion from a 64-bit `long` to a 32-bit `int`. Since `2147483648L` exceeds the maximum positive value an `int` can hold (`2,147,483,647`), the conversion will **cause an overflow** and result in a **negative value**.

### What Happens Internally
During this casting, Java only keeps the lower 32 bits of the `long` value and discards the higher bits. This truncation leads to a wrapped-around value due to overflow.

### Expected Output
The maximum `int` range is from `-2,147,483,648` to `2,147,483,647`. The value `2147483648L` is exactly `2,147,483,648`, which is one more than the maximum `int` value. Therefore, casting it to an `int` will wrap around to the **minimum `int` value**, `-2,147,483,648`.

So:
```java
System.out.println(b); // Output: -2147483648
```

### Explanation
In binary, `2147483648L` is represented as:
```
10000000000000000000000000000000 (in 32 bits)
```

When casting to an `int`, this binary value represents the two's complement form of `-2,147,483,648`.

### Key Points
- **Overflow** occurs because the value is outside the `int` range.
- The result is the **minimum `int` value** for this specific case.
- It's essential to be cautious with narrowing conversions, especially with values that might exceed the target type's range, as this can lead to unexpected results.

Q - In the given code:

java
Copy code
int a = 1;
int b = Integer.MAX_VALUE;
long c = a + b; // Overflow occurs here
assertEquals(c, -2147483648L);
Explanation of the Output
Here, a is 1 and b is Integer.MAX_VALUE, which is 2,147,483,647.
The expression a + b is evaluated as an int because both a and b are of type int.
Adding 1 to Integer.MAX_VALUE (2,147,483,647 + 1) causes an integer overflow, resulting in Integer.MIN_VALUE (-2,147,483,648), since it exceeds the maximum range of int.
Only after this overflow result is obtained, the value is assigned to c, which is a long. Therefore, c holds the value -2147483648 (the result of the overflowed addition).
The assertion assertEquals(c, -2147483648L); passes, as c indeed equals -2147483648.


Q - 

 interface Sleepable {
        String sleep();
    }

    class Grandparent implements Sleepable {
        public String sleep() {
            return "zzzz";
        }
    }

    class Parent extends Grandparent {
        public String complain() {
            return "TPS reports don't even have a cover letter!";
        }
    }

    class Child extends Parent {
        public String complain() {
            return "Are we there yet!!";
        }
    }

    @Koan
    public void upcastWithInheritance() {
        Child child = new Child();
        Parent parentReference = child; // Why isn't there an explicit cast?
        assertEquals(child instanceof Child, true);
        assertEquals(parentReference instanceof Child, true);
        assertEquals(parentReference instanceof Parent, true);
        assertEquals(parentReference instanceof Grandparent, true);
    }


solution - 

In this example, you are working with a class hierarchy that demonstrates **inheritance** and **upcasting** in Java. Here’s a breakdown of how it works:

### Class Hierarchy
1. **`Sleepable` Interface**:
   - Declares a `sleep()` method that is implemented by the `Grandparent` class.

2. **`Grandparent` Class**:
   - Implements `Sleepable` and provides an implementation of `sleep()`.
   
3. **`Parent` Class**:
   - Extends `Grandparent` and adds a `complain()` method.
   
4. **`Child` Class**:
   - Extends `Parent` and overrides the `complain()` method.

### Upcasting
In the `upcastWithInheritance` method:
```java
Child child = new Child();
Parent parentReference = child;
```
The variable `child` is declared as a `Child`, but then assigned to `parentReference`, which is of type `Parent`. Here, an **upcast** occurs because `Child` extends `Parent`. This conversion from `Child` to `Parent` happens **implicitly** because Java allows this automatic conversion from a subclass to a superclass without needing an explicit cast.

### Explanation of Assertions
Each `assertEquals` statement checks if `parentReference` is an instance of various classes in the hierarchy:

1. **`assertEquals(child instanceof Child, true);`**  
   - `child` is of type `Child`, so this returns `true`.

2. **`assertEquals(parentReference instanceof Child, true);`**  
   - `parentReference` is actually a reference to a `Child` object, even though it is typed as `Parent`. Since the underlying object is still a `Child`, this returns `true`.

3. **`assertEquals(parentReference instanceof Parent, true);`**  
   - Since `parentReference` is of type `Parent` (though it holds a `Child` object), this also returns `true`.

4. **`assertEquals(parentReference instanceof Grandparent, true);`**  
   - The `Child` class indirectly extends `Grandparent` through `Parent`, so `parentReference` is also an instance of `Grandparent`. This returns `true` as well.

### Key Points
- **Upcasting** does not require an explicit cast because it is safe to treat a subclass as its superclass.
- **`instanceof` Operator** checks the actual object type, not just the reference type, so it can correctly identify that `parentReference` is an instance of `Child`, `Parent`, and `Grandparent`.
- **Polymorphism**: Even though `parentReference` is typed as `Parent`, it still behaves like a `Child` object because the actual object is of type `Child`.

By using `instanceof`, Java ensures that `parentReference` retains the type information of `Child`, demonstrating the flexibility and hierarchical nature of inheritance and polymorphism.


Q - this is related with above questions class code

    @Koan
    public void upcastAndPolymorphism() {
        Child child = new Child();
        Parent parentReference = child;
        // If the result is unexpected, consider the difference between an instance and
        // its reference
        assertEquals(parentReference.complain(), "Are we there yet!!"); // this will return true
    }


Q -     @Koan
    public void downcastWithInheritance() {
        Grandparent child = new Child();
        Parent parentReference = (Parent) child; // Why do we need an explicit cast here?
        Child childReference = (Child) parentReference; // Or here?
        assertEquals(childReference instanceof Child, true);
        assertEquals(childReference instanceof Parent, true);
        assertEquals(childReference instanceof Grandparent, true);
    }


Solution - In the `downcastWithInheritance` method, you're exploring **downcasting** in Java, where you cast an object to a subclass type. Let’s break down what’s happening here:

### Class Hierarchy Recap
1. **`Grandparent`** implements the `Sleepable` interface.
2. **`Parent`** extends `Grandparent`.
3. **`Child`** extends `Parent` and overrides the `complain()` method.

### Code Explanation
```java
Grandparent child = new Child();
Parent parentReference = (Parent) child; // Explicit cast required
Child childReference = (Child) parentReference; // Explicit cast required
```

#### Step-by-Step Explanation
1. **Assigning a `Child` instance to a `Grandparent` reference**:
   ```java
   Grandparent child = new Child();
   ```
   - This is an example of **upcasting**, which is implicit and doesn’t require an explicit cast because `Child` is a subclass of `Grandparent`.

2. **Casting `child` (which holds a `Child` object) to a `Parent`**:
   ```java
   Parent parentReference = (Parent) child;
   ```
   - Here, you need an **explicit cast** because `child` is currently typed as a `Grandparent`. While the actual object is a `Child`, the compiler only knows that `child` is of type `Grandparent`, so it requires a cast to `Parent`. 
   - This is **downcasting**, as you’re casting from a superclass (`Grandparent`) to a subclass (`Parent`).

3. **Casting `parentReference` (which holds a `Child` object) to a `Child`**:
   ```java
   Child childReference = (Child) parentReference;
   ```
   - Again, an explicit cast is required here because `parentReference` is typed as a `Parent`, even though it refers to a `Child` object. The compiler needs confirmation that you intend to treat `parentReference` as a `Child` object.

### Why Explicit Casts Are Required
- In **upcasting**, the assignment is always allowed implicitly because a subclass is a type of its superclass.
- In **downcasting**, you need an explicit cast because not every `Grandparent` is a `Parent` and not every `Parent` is a `Child`. Downcasting could potentially fail at runtime, so Java requires the explicit cast as a safeguard.

### Explanation of Assertions
```java
assertEquals(childReference instanceof Child, true);
assertEquals(childReference instanceof Parent, true);
assertEquals(childReference instanceof Grandparent, true);
```
- **`childReference instanceof Child`** checks that `childReference` is indeed a `Child` object, which is true.
- **`childReference instanceof Parent`** confirms that `childReference`, as a `Child`, is also an instance of `Parent`, due to inheritance, so it returns `true`.
- **`childReference instanceof Grandparent`** also returns `true` since `Child` inherits from `Parent` and indirectly from `Grandparent`.

### Summary
- **Downcasting** requires an explicit cast because it can lead to runtime exceptions (e.g., `ClassCastException`) if the object is not actually an instance of the subclass.
- **`instanceof` Operator** verifies the actual type of the object, affirming that `childReference` is a `Child` object and also belongs to the `Parent` and `Grandparent` classes.
- This example illustrates Java's **inheritance hierarchy** and how objects retain information about their actual type even when referenced by a superclass type.


Q -     @Koan
    public void downcastAndPolymorphism() {
        Grandparent child = new Child();
        Parent parent = (Child) child;
        // Think about the result. Did you expect that? Why?
        // How is that different from above?
        assertEquals(parent.complain(), "Are we there yet!!");
    }

Solution - 

In this `downcastAndPolymorphism` method, you’re exploring how **downcasting** interacts with **polymorphism** in Java. Let's break down the code and see what's happening:

### Class Hierarchy Recap
1. **`Grandparent`** implements the `Sleepable` interface and defines a `sleep()` method.
2. **`Parent`** extends `Grandparent` and defines a `complain()` method.
3. **`Child`** extends `Parent` and overrides the `complain()` method.

### Code Explanation
```java
Grandparent child = new Child();
Parent parent = (Child) child;
```
1. **Instantiating a `Child` object with a `Grandparent` reference**:
   ```java
   Grandparent child = new Child();
   ```
   - This line upcasts a `Child` object to a `Grandparent` reference. This is allowed implicitly since `Child` is a subclass of `Grandparent`.

2. **Downcasting the `Grandparent` reference to `Parent`**:
   ```java
   Parent parent = (Child) child;
   ```
   - Here, you’re explicitly downcasting the `child` (which is a `Grandparent` reference but refers to a `Child` object) to `Parent`. The cast is necessary because `child` is a `Grandparent` type.
   - You’re actually casting `child` directly to `Child`, but it’s assigned to a `Parent` variable (`parent`). This works because `Child` is also a `Parent`.
   - At runtime, Java knows `child` is really a `Child`, so it performs this cast successfully.

3. **Calling `parent.complain()`**:
   ```java
   assertEquals(parent.complain(), "Are we there yet!!");
   ```
   - This is where **polymorphism** comes into play. The `parent` reference is of type `Parent`, but the actual object is a `Child`. 
   - Since `complain()` is overridden in `Child`, Java uses the **overridden method** in `Child`, so the output is `"Are we there yet!!"`.

### Key Points
- **Downcasting** lets you access subclass-specific methods, and since `parent` is actually a `Child` object, it allows you to call the overridden `complain()` method in `Child`.
- **Polymorphism** ensures that when you call `complain()` on `parent`, the `Child` class’s `complain()` method is executed instead of `Parent`’s, even though `parent` is typed as `Parent`.
- This is different from a typical method call on a superclass instance because **dynamic method dispatch** ensures that the actual class’s (runtime) method is executed, not the reference type’s (compile-time) method.

### Why This Works
- Java always uses **dynamic binding** (or **late binding**) for method calls, meaning the actual object type determines which method implementation is executed at runtime.
- The result may be surprising because the method called is from `Child`, even though `parent` is typed as `Parent`. This is due to **polymorphism**, which ensures the most specific overridden method (in the actual object type) is called.

### Summary
- **Downcasting** allows access to the full range of subclass-specific methods.
- **Polymorphism** guarantees that overridden methods execute according to the actual object type, not just the reference type.
- The output `“Are we there yet!!”` confirms that `Child`’s version of `complain()` is invoked due to the actual object being a `Child`, even when accessed through a `Parent` reference.


Q - In Java, the equals method is defined in the Object class and is used to compare two objects for equality. By default, the equals method in the Object class performs a reference comparison, meaning it checks whether the two references point to the same memory location.

Here’s how the default equals method in the Object class works:

java
Copy code
public boolean equals(Object obj) {
    return (this == obj);
}


Q - 

    @Koan
    public void complicatedCast() {
        Grandparent parent = new Parent();
        // How can we access the parent's ability to "complain" - if the reference is
        // held as a superclass?
        assertEquals("TPS reports don't even have a cover letter!", ((Parent) parent).complain());
    }


-->

In the provided code snippet, the method `complicatedCast` demonstrates the concept of **type casting** in Java, particularly in the context of class inheritance. Here's a breakdown of the code and its implications:

### Code Explanation

```java
@Koan
public void complicatedCast() {
    Grandparent parent = new Parent();
    // How can we access the parent's ability to "complain" - if the reference is
    // held as a superclass?
    assertEquals("TPS reports don't even have a cover letter!", ((Parent) parent).complain());
}
```

### Breakdown of the Code

1. **Class Hierarchy**:
   - `Grandparent`: This is the superclass.
   - `Parent`: This class extends `Grandparent` and includes a method called `complain()`. The implementation of `complain()` returns a specific string.

2. **Creating a Reference**:
   - `Grandparent parent = new Parent();`
     - Here, you create a new instance of `Parent` but store it in a reference of type `Grandparent`. This is a valid operation in Java due to polymorphism, where a subclass object can be referenced by a superclass reference.

3. **Accessing Subclass Methods**:
   - The key question raised in the comment is how to access the `complain()` method of `Parent` when the reference type is `Grandparent`. The answer lies in **type casting**.
   - The expression `((Parent) parent)` performs an **explicit cast** from `Grandparent` to `Parent`. This tells the Java compiler that you are confident that `parent` is actually referring to an object of type `Parent`.
   - After the cast, you can then call `complain()` on the object.

4. **Assertion**:
   - The line `assertEquals("TPS reports don't even have a cover letter!", ((Parent) parent).complain());` checks if the result of calling `complain()` on the `Parent` instance matches the expected string. If the cast is successful and `complain()` works as intended, the assertion will pass.

### Important Concepts

- **Polymorphism**: This example illustrates polymorphism where a subclass object can be treated as an object of its superclass. However, to access subclass-specific methods, you need to cast the reference back to the subclass type.
  
- **Type Casting**: The explicit cast `(Parent) parent` is essential here. Without it, the Java compiler would not allow the call to `complain()` since it recognizes `parent` as a `Grandparent` type, which does not have the `complain()` method.

- **Risks of Casting**: 
  - If `parent` were pointing to an instance of a different subclass of `Grandparent` that does not extend `Parent`, a `ClassCastException` would be thrown at runtime.
  - It's good practice to use the `instanceof` operator before performing a cast to ensure that the reference is indeed of the expected subclass type.

### Conclusion
The method `complicatedCast` demonstrates how to utilize type casting to access subclass-specific methods while maintaining a reference of a superclass type. This technique is fundamental in Java's object-oriented programming paradigm, allowing for flexibility and reuse of code through polymorphism.


Q - Why can't we make constructors static - 

No, we cannot make a constructor static in Java. Constructors are inherently tied to the creation of an instance of a class, and static methods belong to the class itself rather than to any particular instance. Here’s why constructors cannot be static:

### Reasons Why Constructors Can't Be Static
1. **Instance Creation**:
   - Constructors are used to initialize new instances of a class. They set up the initial state of an object, which requires access to instance-level data. 
   - Static methods, on the other hand, belong to the class itself and cannot access instance variables directly because they are not associated with any specific object.

2. **Static Methods Don’t Require an Object**:
   - Static methods can be called without creating an instance of a class. Since constructors are meant to create instances, it wouldn’t make sense for them to be static.
   
3. **Purpose of Static**:
   - The `static` keyword in Java denotes that a member belongs to the class as a whole, not to any particular instance of the class. A static constructor would imply that it’s meant to initialize the class itself, not an instance of it, which goes against the purpose of constructors.

### Alternative: Static Initialization Blocks
If you need to perform some static initialization (such as initializing static variables), you can use a **static initialization block** instead. This block is executed when the class is loaded, and it doesn’t require an instance of the class.

```java
public class Example {
    static {
        // Static initialization code here
        System.out.println("Static initialization block executed");
    }

    public Example() {
        // Instance initialization code here
        System.out.println("Constructor executed");
    }
}
```

In this example, the static initialization block will run only once when the class is loaded, whereas the constructor will run every time a new instance of the class is created.


Q - 

    class A {
        public String doStuff(int i) {
            return "int";
        }

        public String doStuff(Integer i) {
            return "Integer";
        }

        public String doStuff(Object i) {
            return "Object";
        }

        public String doStuff(int... i) {
            return "int vararg";
        }
    }



    @Koan
    public void methodPreferenceLong() {
        long l = 1;
        assertEquals(new A().doStuff(l), "Object"); // this will pass, this is calling the constructor which is taking the Object as a input.

    }


Bitwise operators - 

In Java, bitwise operators are used to perform operations on individual bits of integer types (like `int`, `long`, `short`, `byte`, etc.). Here’s a summary of the bitwise operators available in Java, along with their functionality:

### 1. Bitwise AND (`&`)
- **Description:** Compares each bit of two integers; if both bits are `1`, the corresponding result bit is set to `1`. Otherwise, it is set to `0`.
- **Example:**
  ```java
  int a = 5;    // (0101 in binary)
  int b = 3;    // (0011 in binary)
  int result = a & b; // result is 1 (0001 in binary)
  ```

### 2. Bitwise OR (`|`)
- **Description:** Compares each bit of two integers; if at least one of the bits is `1`, the corresponding result bit is set to `1`. Otherwise, it is set to `0`.
- **Example:**
  ```java
  int a = 5;    // (0101 in binary)
  int b = 3;    // (0011 in binary)
  int result = a | b; // result is 7 (0111 in binary)
  ```

### 3. Bitwise XOR (`^`)
- **Description:** Compares each bit of two integers; if the bits are different (one is `0` and the other is `1`), the corresponding result bit is set to `1`. Otherwise, it is set to `0`.
- **Example:**
  ```java
  int a = 5;    // (0101 in binary)
  int b = 3;    // (0011 in binary)
  int result = a ^ b; // result is 6 (0110 in binary)
  ```

### 4. Bitwise Complement (`~`)
- **Description:** Flips all the bits of the integer (changes `1`s to `0`s and `0`s to `1`s).
- **Example:**
  ```java
  int a = 5;    // (0101 in binary)
  int result = ~a; // result is -6 (inverts to 1010 in binary for 32-bit)
  ```

### 5. Left Shift (`<<`)
- **Description:** Shifts the bits of the integer to the left by a specified number of positions. Zero bits are shifted in from the right.
- **Example:**
  ```java
  int a = 5;    // (0000 0000 0000 0000 0000 0000 0000 0101)
  int result = a << 1; // result is 10 (0000 0000 0000 0000 0000 0000 0000 1010)
  ```

### 6. Right Shift (`>>`)
- **Description:** Shifts the bits of the integer to the right by a specified number of positions. The sign bit (leftmost bit) is copied to fill in the new leftmost bits, preserving the sign of the number (arithmetic shift).
- **Example:**
  ```java
  int a = -8;   // (1111 1111 1111 1111 1111 1111 1111 1000)
  int result = a >> 2; // result is -2 (1111 1111 1111 1111 1111 1111 1111 1110)
  ```

### 7. Unsigned Right Shift (`>>>`)
- **Description:** Shifts the bits of the integer to the right by a specified number of positions, filling in `0`s from the left regardless of the sign (logical shift).
- **Example:**
  ```java
  int a = -8;   // (1111 1111 1111 1111 1111 1111 1111 1000)
  int result = a >>> 2; // result is 1073741822 (0011 1111 1111 1111 1111 1111 1111 1110)
  ```

### Summary
Bitwise operators are useful for low-level programming, manipulating bits directly for various tasks such as encryption, graphics processing, and performance optimization. They can also be handy when dealing with flags, masks, or binary data.

### Example Code
Here's a complete example demonstrating the use of these bitwise operators:

```java
public class BitwiseOperatorsDemo {
    public static void main(String[] args) {
        int a = 5;  // 0101 in binary
        int b = 3;  // 0011 in binary

        // Bitwise AND
        System.out.println("a & b: " + (a & b)); // 1

        // Bitwise OR
        System.out.println("a | b: " + (a | b)); // 7

        // Bitwise XOR
        System.out.println("a ^ b: " + (a ^ b)); // 6

        // Bitwise Complement
        System.out.println("~a: " + (~a)); // -6

        // Left Shift
        System.out.println("a << 1: " + (a << 1)); // 10

        // Right Shift
        int c = -8; // 1111 1111 1111 1111 1111 1111 1111 1000
        System.out.println("c >> 2: " + (c >> 2)); // -2

        // Unsigned Right Shift
        System.out.println("c >>> 2: " + (c >>> 2)); // 1073741822
    }
}
```

This will give you a clearer understanding of how each bitwise operator works in Java.


Q - Array - 

In Java, the expression `new int[] { 1 }.equals(new int[] { 1 })` will return `false`. This is because the `equals()` method in Java, when called on an array, does not compare the contents of the array. Instead, it checks for reference equality, meaning it checks whether the two array references point to the same object in memory.

### Explanation

1. **Array Creation:**
   - `new int[] { 1 }` creates a new array object containing a single integer, `1`.
   - Each call to `new int[] { 1 }` creates a separate and distinct array object in memory.

2. **Using `equals()`:**
   - When you call `equals()` on the first array, it will compare its reference (i.e., memory address) with the reference of the second array.
   - Since both arrays were created separately, they occupy different locations in memory.

3. **Result of `equals()`:**
   - Because the references of the two arrays are different, `equals()` returns `false`.

### Example
Here’s a simple example demonstrating this:

```java
public class ArrayEqualsDemo {
    public static void main(String[] args) {
        int[] array1 = new int[] { 1 };
        int[] array2 = new int[] { 1 };

        // This will print false because they are different objects
        System.out.println(array1.equals(array2)); // Output: false
    }
}
```

### Correct Way to Compare Arrays
If you want to compare the contents of two arrays in Java, you should use the `Arrays.equals()` method from the `java.util.Arrays` class, which is designed to compare the contents of arrays:

```java
import java.util.Arrays;

public class ArrayComparison {
    public static void main(String[] args) {
        int[] array1 = new int[] { 1 };
        int[] array2 = new int[] { 1 };

        // This will print true because it compares the contents
        System.out.println(Arrays.equals(array1, array2)); // Output: true
    }
}
```

In summary, the output of `new int[] { 1 }.equals(new int[] { 1 })` is `false` because it checks for reference equality, not content equality. To compare the contents of the arrays, use `Arrays.equals()`.

Q - 


The expression `original.equals(original.clone())` returns `false` in Java, and here's why:

### Breakdown of the Code

1. **Array Creation:**
   ```java
   int[] original = new int[] { 1 };
   ```
   This line creates a new integer array named `original` with a single element, `1`.

2. **Cloning the Array:**
   ```java
   original.clone()
   ```
   The `clone()` method creates a shallow copy of the `original` array. This means a new array object is created in memory, containing the same elements as the original array. However, the new array is a different object with its own reference.

3. **Using `equals()`:**
   ```java
   original.equals(original.clone())
   ```
   When you call `equals()` on an array (in this case, `original`), it checks for reference equality, not content equality. Since `original` and the result of `original.clone()` are two different objects (even though they contain the same elements), the `equals()` method will return `false`.

### Explanation
- **Reference Equality:** 
  - The `equals()` method for objects, when not overridden (like in the case of arrays), uses the default implementation from the `Object` class, which checks if two references point to the same object in memory.
- **Different Objects:** 
  - In this case, `original` and `original.clone()` refer to different array objects, so `original.equals(original.clone())` evaluates to `false`.

### Example Code

Here’s a complete example illustrating this behavior:

```java
public class ArrayEqualsDemo {
    public static void main(String[] args) {
        int[] original = new int[] { 1 };

        // Cloning the original array
        int[] clonedArray = original.clone();

        // Check if the original and the cloned array are equal
        boolean areEqual = original.equals(clonedArray); // This will be false

        System.out.println(areEqual); // Output: false
    }
}
```

### Correct Way to Compare Array Contents

If you want to check if both arrays contain the same elements, you should use `Arrays.equals()` from the `java.util.Arrays` class:

```java
import java.util.Arrays;

public class ArrayComparison {
    public static void main(String[] args) {
        int[] original = new int[] { 1 };
        int[] clonedArray = original.clone();

        // Check if the contents of the original and cloned arrays are equal
        boolean areContentsEqual = Arrays.equals(original, clonedArray); // This will be true

        System.out.println(areContentsEqual); // Output: true
    }
}
```

### Summary
In summary, `original.equals(original.clone())` returns `false` because `equals()` checks for reference equality, and the original and cloned arrays are two different objects in memory, even though their contents are the same. To compare the contents of the arrays, use `Arrays.equals()`.


Q - 

In the given code snippet:

```java
int[] array0 = new int[] { 0 };
int[] array1 = new int[] { 0 };
Integer.valueOf(array0.hashCode()).equals(array1.hashCode());
```

### Explanation of Each Part:

1. **Array Creation:**
   ```java
   int[] array0 = new int[] { 0 };
   int[] array1 = new int[] { 0 };
   ```
   This creates two separate integer arrays, `array0` and `array1`, both containing a single element with the value `0`.

2. **Hash Code Calculation:**
   ```java
   array0.hashCode()
   ```
   This calls the `hashCode()` method on `array0`. In Java, the `hashCode()` method for arrays is not overridden, so it uses the default implementation from the `Object` class. This means it will return a hash code based on the object's reference in memory, not the contents of the array.

3. **Integer Conversion:**
   ```java
   Integer.valueOf(array0.hashCode())
   ```
   This converts the hash code of `array0` into an `Integer` object.

4. **Equality Check:**
   ```java
   Integer.valueOf(array0.hashCode()).equals(array1.hashCode())
   ```
   Here, you're comparing the `Integer` object created from `array0`'s hash code with the primitive `int` result of `array1.hashCode()`. When an `Integer` is compared with an `int`, Java will unbox the `Integer` to an `int` and then compare the two integer values.

### Why the Comparison May Not Work as Expected

Since both `array0` and `array1` are different array objects, their hash codes will likely be different, resulting in the following:
- `array0.hashCode()` and `array1.hashCode()` will return different hash codes because they are separate objects.
- The `equals()` method in `Integer` will evaluate the integer values derived from these hash codes.

### Conclusion

Because `array0` and `array1` are different objects, their hash codes will differ in most cases, and thus the comparison:

```java
Integer.valueOf(array0.hashCode()).equals(array1.hashCode())
```

will **most likely return `false`**.

### Example to Illustrate

Here's a complete code example to illustrate this:

```java
public class HashCodeExample {
    public static void main(String[] args) {
        int[] array0 = new int[] { 0 };
        int[] array1 = new int[] { 0 };

        int hash0 = array0.hashCode();
        int hash1 = array1.hashCode();

        System.out.println("Hash code of array0: " + hash0);
        System.out.println("Hash code of array1: " + hash1);

        boolean areEqual = Integer.valueOf(hash0).equals(hash1);
        System.out.println("Are the hash codes equal? " + areEqual);
    }
}
```

When you run this code, you will see that the hash codes are different, and therefore, the output will be `false`. This is because the default `hashCode()` method for arrays does not account for their contents, only their reference.


Q - 

In Java, **varargs** (variable-length arguments) allow you to pass a variable number of arguments to a method. This feature provides flexibility in method definitions and can make it easier to call methods when the number of parameters is not fixed.

### Syntax

The syntax for varargs is to use an ellipsis (`...`) followed by the data type of the argument. This is typically placed at the end of the method parameter list. Here's the general form:

```java
public void methodName(DataType... varName) {
    // Method body
}
```

### How Varargs Work

- When you define a method with varargs, Java treats the arguments as an array. You can access the individual elements of this array inside the method.
- You can pass zero or more arguments when calling the method.

### Example

Here's a simple example to demonstrate how to use varargs:

```java
public class VarArgsExample {
    
    // Method that accepts variable number of integer arguments
    public static void printNumbers(int... numbers) {
        for (int number : numbers) {
            System.out.print(number + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // Calling the method with different numbers of arguments
        printNumbers();                  // No arguments
        printNumbers(1);                 // One argument
        printNumbers(1, 2, 3);           // Three arguments
        printNumbers(4, 5, 6, 7, 8, 9);  // Many arguments
    }
}
```

### Output

```
1 2 3 
4 5 6 7 8 9 
```

### Important Points

1. **Only One Varargs Parameter**: You can have only one varargs parameter in a method, and it must be the last parameter. For example, the following is not allowed:
   ```java
   public void method(int... numbers, String name) { // This will cause a compile-time error
   }
   ```

2. **Default Array**: If you call a method with no arguments, Java initializes the varargs parameter to an empty array. For example, in `printNumbers()`, `numbers` will be an empty array.

3. **Mixing Parameters**: You can mix regular parameters with varargs. However, the varargs parameter must be placed at the end of the parameter list:
   ```java
   public void exampleMethod(String str, int... nums) {
       // Method body
   }
   ```

4. **Using Varargs with Arrays**: You can also pass an existing array to a method that takes varargs:
   ```java
   int[] array = {1, 2, 3};
   printNumbers(array); // Works because it matches the parameter type
   ```

5. **Not for Primitive Types**: The varargs mechanism works for all types, including primitives, objects, and even generic types. However, when you use varargs with a primitive type, you still use the corresponding wrapper class when treating it as an object.

### Conclusion

Varargs provide a powerful feature for writing flexible methods in Java, allowing you to handle multiple parameters more easily. They enhance the readability and usability of your code, especially when the number of arguments can vary.


Q - SubMap - 


In Java's `java.util` package, `Map` provides various implementations like `HashMap`, `TreeMap`, etc., with different functionalities. The `subMap` method is specifically available in `TreeMap`, which is a part of the SortedMap interface. 

The `subMap` method is used to retrieve a portion of the map based on a specified range of keys. Since `TreeMap` maintains its elements in a sorted order (according to natural ordering or a provided comparator), it can efficiently provide a submap view that contains elements within a certain range.

### `TreeMap.subMap()` Method Overview

The `subMap()` method of `TreeMap` has two forms:
1. **`SortedMap<K, V> subMap(K fromKey, K toKey)`**
2. **`NavigableMap<K, V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)`**

#### 1. `subMap(K fromKey, K toKey)`
- **Purpose**: Returns a view of the portion of this map whose keys range from `fromKey` (inclusive) to `toKey` (exclusive).
- **Parameters**:
  - `fromKey`: The lower bound (inclusive) for the keys in the returned map.
  - `toKey`: The upper bound (exclusive) for the keys in the returned map.
- **Return Type**: `SortedMap<K, V>`
- **Behavior**:
  - The returned map is backed by the original map, so changes in the submap reflect in the original map, and vice versa.
  - If you attempt to insert a key outside the specified range, it throws an `IllegalArgumentException`.

**Example**:
```java
TreeMap<Integer, String> treeMap = new TreeMap<>();
treeMap.put(1, "One");
treeMap.put(2, "Two");
treeMap.put(3, "Three");
treeMap.put(4, "Four");
treeMap.put(5, "Five");

SortedMap<Integer, String> subMap = treeMap.subMap(2, 5);
System.out.println(subMap); // Output: {2=Two, 3=Three, 4=Four}
```

#### 2. `subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)`
- **Purpose**: Returns a view of the portion of this map whose keys range from `fromKey` to `toKey`, with the option to include or exclude the endpoints.
- **Parameters**:
  - `fromKey`: The lower bound for the keys in the returned map.
  - `fromInclusive`: Whether to include `fromKey` in the returned map.
  - `toKey`: The upper bound for the keys in the returned map.
  - `toInclusive`: Whether to include `toKey` in the returned map.
- **Return Type**: `NavigableMap<K, V>`
- **Behavior**:
  - The returned map respects the inclusivity settings for both bounds.
  - Similar to the other form, changes in this submap are reflected in the original map.

**Example**:
```java
NavigableMap<Integer, String> navigableSubMap = treeMap.subMap(2, true, 5, true);
System.out.println(navigableSubMap); // Output: {2=Two, 3=Three, 4=Four, 5=Five}
```

### Key Characteristics
- **Backed Map**: Both forms of `subMap` return views of the map, not copies, so any modification in the submap is directly reflected in the original map.
- **Range Checking**: The submap is limited to the specified range of keys. Accessing keys outside this range throws `IllegalArgumentException`.
- **Inclusivity**: In the `NavigableMap` version, you have more control over the inclusivity of the bounds.

### Use Cases
- **Range Queries**: Efficiently querying a subset of keys within a specific range.
- **Submap Operations**: Perform operations (like `put`, `remove`, `replace`) on a specific range of keys without affecting the entire map.
  
### Potential Exceptions
- **IllegalArgumentException**: If the `fromKey` is greater than the `toKey`, or if the map does not contain keys within the specified range.
- **NullPointerException**: If any key is `null` and the map does not permit null keys (which `TreeMap` does not).

The `subMap` method is particularly useful when working with large datasets, as it allows working with relevant segments of the data without having to copy them.

No, you cannot insert the key `6` into the submap `subMap` created using `subMap(2, 5)`. The reason is that the range of keys in this submap is restricted to the interval `[2, 5)`, which means it includes keys `2`, `3`, and `4`, but not `5` or any key greater than `5`. Since `6` is outside this range, attempting to put it into the `subMap` will result in an `IllegalArgumentException`.

The `subMap` enforces its key range boundaries, so only keys within the specified range can be added, updated, or removed. Here's an example that demonstrates this:

```java
TreeMap<Integer, String> treeMap = new TreeMap<>();
treeMap.put(1, "One");
treeMap.put(2, "Two");
treeMap.put(3, "Three");
treeMap.put(4, "Four");
treeMap.put(5, "Five");

SortedMap<Integer, String> subMap = treeMap.subMap(2, 5);

// Attempting to add a key outside of the submap range
subMap.put(6, "Six"); // This will throw an IllegalArgumentException
```

If you need to add the key `6` to the map, you must either:
1. Use the original `treeMap`, which has no restrictions on key values:
   ```java
   treeMap.put(6, "Six"); // This will work
   ```
2. Expand the range of your submap to include `6`, if possible:
   ```java
   SortedMap<Integer, String> expandedSubMap = treeMap.subMap(2, 7); // Expands the range to include 6
   expandedSubMap.put(6, "Six"); // This will work now
   ```

In your current `subMap` setup, however, only keys `2`, `3`, and `4` are valid for insertion or updating.


Q - static class - 

In Java, a `static` class is a nested class declared with the `static` modifier. This means that it is a member of the outer class but does not require an instance of the outer class to be created. Unlike regular nested classes (also known as inner classes), a `static` nested class can be accessed independently of an instance of the outer class.

### Characteristics of Static Classes
1. **Defined within another class**: A `static` class is always a nested class; it cannot exist on its own. It is declared within an outer class.
2. **Independent of Outer Class Instance**: Since it is `static`, you do not need to create an instance of the outer class to instantiate or access a static nested class.
3. **Access to Outer Class Members**: A static nested class can only directly access static members (methods and variables) of the outer class. It cannot directly access non-static members of the outer class.
4. **Use Cases**: Static nested classes are often used when they are only logically grouped with the outer class but do not require access to its instance-specific members. They're also used for organizing classes that are only relevant within the context of the outer class.

### Syntax
Here’s how you declare a static nested class:

```java
public class OuterClass {
    private static int staticValue = 10;
    private int instanceValue = 20;

    // Static nested class
    public static class StaticNestedClass {
        public void display() {
            // Can access static members of the outer class
            System.out.println("Static value: " + staticValue);
            
            // Cannot access non-static members of the outer class directly
            // System.out.println("Instance value: " + instanceValue); // This would cause an error
        }
    }
}
```

### Creating an Instance of a Static Nested Class
You do not need an instance of the outer class to create an instance of the static nested class. Instead, you create an instance using the outer class name:

```java
public class Main {
    public static void main(String[] args) {
        // Creating an instance of the static nested class
        OuterClass.StaticNestedClass nestedInstance = new OuterClass.StaticNestedClass();
        nestedInstance.display();
    }
}
```

### Key Differences Between Static Nested Classes and Inner Classes
1. **Instance Dependency**: A static nested class does not require an instance of the outer class, while an inner class does.
2. **Access to Members**: A static nested class can only access the static members of the outer class, while an inner class can access both static and non-static members.
3. **Memory Efficiency**: Static nested classes can help save memory since they don’t keep a reference to the outer class instance, whereas inner classes do.

### Use Cases
- **Helper Classes**: When you need a helper class that's only used by the outer class, making it static avoids extra object references and keeps it closely associated with the outer class.
- **Grouping Related Classes**: If a class is only useful in conjunction with another class, a static nested class can provide a logical grouping without exposing it as a top-level class.

In summary, a static nested class in Java provides a way to define a class that is logically related to another class, without needing to access instance-specific members of that class.


Q - Date - 

In Java, the `Date` class is a part of the `java.util` package and represents a specific moment in time, with millisecond precision. It was introduced in early versions of Java (Java 1.0) and has since been largely replaced by the `java.time` package (introduced in Java 8), which offers more comprehensive date and time handling. However, the `Date` class is still widely used, especially for backward compatibility.

### Characteristics of `Date` Class
- **Represents Date and Time**: A `Date` object encapsulates both the date (day, month, year) and the time (hours, minutes, seconds, milliseconds).
- **Timezone Independent**: A `Date` object itself does not contain timezone information. When you print or display a `Date`, it is typically displayed in the system's default timezone.
- **Mutable**: `Date` is mutable, meaning its value can be changed after creation.
- **Deprecated Methods**: Many of its original methods for date manipulation are deprecated because they have been replaced by the `Calendar` and `java.time` API classes for better accuracy and timezone support.

### Creating a `Date` Object
You can create a `Date` object in several ways:
1. **Current Date and Time**:
   ```java
   Date currentDate = new Date();
   ```

2. **Date from Milliseconds**: 
   - You can specify a date by providing the number of milliseconds since the "epoch" (January 1, 1970, 00:00:00 GMT).
   ```java
   long millis = System.currentTimeMillis();
   Date dateFromMillis = new Date(millis);
   ```

### Important Methods in `Date` Class
Even though many methods in `Date` are deprecated, the following are some commonly used methods:

1. **`getTime()`**:
   - Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT.
   ```java
   long milliseconds = currentDate.getTime();
   ```

2. **`setTime(long time)`**:
   - Sets the `Date` object to represent a time specified in milliseconds since January 1, 1970, 00:00:00 GMT.
   ```java
   currentDate.setTime(milliseconds);
   ```

3. **`before(Date when)` / `after(Date when)`**:
   - Checks if the date is before or after a specific date.
   ```java
   boolean isBefore = currentDate.before(new Date());
   boolean isAfter = currentDate.after(new Date());
   ```

4. **`compareTo(Date anotherDate)`**:
   - Compares two dates. Returns 0 if equal, a value less than 0 if this date is before the specified date, and a value greater than 0 if this date is after the specified date.
   ```java
   int comparison = currentDate.compareTo(anotherDate);
   ```

5. **`toString()`**:
   - Converts the `Date` object into a readable string representation.
   ```java
   System.out.println(currentDate.toString()); // Example: Wed Oct 11 10:45:20 PDT 2023
   ```

### Deprecated Methods
Some of the original methods, such as `getYear()`, `getMonth()`, `getDay()`, `setHours()`, `setMinutes()`, and others, are deprecated. They are considered unreliable and have been replaced by more robust alternatives like `Calendar` and `java.time` classes.

### Formatting and Parsing Dates
While the `Date` class does not directly support formatting and parsing, you can use `SimpleDateFormat` (from `java.text` package) to format and parse `Date` objects:

```java
import java.text.SimpleDateFormat;
import java.util.Date;

Date date = new Date();
SimpleDateFormat formatter = new SimpleDateFormat("dd-MM-yyyy HH:mm:ss");
String formattedDate = formatter.format(date);
System.out.println(formattedDate); // Output: e.g., 11-10-2023 10:45:20
```

### Alternatives to `Date`
The `java.time` package (introduced in Java 8) provides more flexible and accurate classes for handling date and time:
- **`LocalDate`**: Represents only a date without time and timezone.
- **`LocalTime`**: Represents only a time without date and timezone.
- **`LocalDateTime`**: Represents both date and time without timezone.
- **`ZonedDateTime`**: Represents date, time, and timezone.
- **`Instant`**: Represents an instantaneous point on the timeline, with nanosecond precision.

These classes are immutable and offer better API methods for date-time manipulation and formatting.

### Example Usage
Here's a simple example using the `Date` class to get the current date and compare it with another date:

```java
import java.util.Date;

public class DateExample {
    public static void main(String[] args) {
        Date currentDate = new Date();
        System.out.println("Current Date: " + currentDate);

        // Create a date in the past
        Date pastDate = new Date(currentDate.getTime() - (1000 * 60 * 60 * 24)); // 1 day ago
        System.out.println("Past Date: " + pastDate);

        // Compare dates
        if (pastDate.before(currentDate)) {
            System.out.println("The past date is before the current date.");
        }
    }
}
```

The `Date` class remains useful for simple date manipulation and backward compatibility, but for complex date and time operations, it is recommended to use the newer `java.time` classes.


Q - Calendar - 


In Java, the `Calendar` class is part of the `java.util` package and provides methods for date and time manipulation. Unlike the `Date` class, the `Calendar` class is more flexible and allows for working with dates and times with various fields like year, month, day, hour, minute, second, etc. It also supports localization and can handle timezone conversions. 

### Characteristics of `Calendar` Class
- **Abstract Class**: The `Calendar` class is abstract, so you cannot instantiate it directly. You typically obtain an instance using the `getInstance()` method, which provides a `Calendar` object initialized to the current date and time in the default timezone.
- **Fields**: The `Calendar` class represents various components of date and time as individual fields such as `YEAR`, `MONTH`, `DAY_OF_MONTH`, `HOUR`, `MINUTE`, `SECOND`, etc.
- **Timezone-Aware**: The `Calendar` class supports timezone conversion and can be set to different timezones.
- **Mutable**: `Calendar` instances are mutable, allowing you to modify the date and time after creation.
- **Locale Support**: It provides localization support and can be customized to fit different cultural formats.

### Creating a `Calendar` Instance
You can create a `Calendar` instance using the static `getInstance()` method. This method returns a `Calendar` object based on the default timezone and locale.

```java
import java.util.Calendar;

Calendar calendar = Calendar.getInstance();
```

You can also create a `Calendar` for a specific timezone or locale:

```java
import java.util.Calendar;
import java.util.TimeZone;

Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
```

### Important Methods in `Calendar` Class

1. **Getting and Setting Fields**
   - **Getting a Field**: Use the `get(int field)` method to retrieve specific components like `YEAR`, `MONTH`, `DAY_OF_MONTH`, etc.
     ```java
     int year = calendar.get(Calendar.YEAR);
     int month = calendar.get(Calendar.MONTH); // Note: January is 0
     int day = calendar.get(Calendar.DAY_OF_MONTH);
     ```

   - **Setting a Field**: Use the `set(int field, int value)` method to modify specific date components.
     ```java
     calendar.set(Calendar.YEAR, 2024);
     calendar.set(Calendar.MONTH, Calendar.MARCH); // March is 2
     calendar.set(Calendar.DAY_OF_MONTH, 10);
     ```

2. **Date Arithmetic**
   - **Adding/Subtracting to Fields**: Use the `add(int field, int amount)` method to add or subtract time.
     ```java
     calendar.add(Calendar.DAY_OF_MONTH, 10); // Adds 10 days
     calendar.add(Calendar.YEAR, -1); // Subtracts 1 year
     ```

   - **Rolling Fields**: The `roll(int field, int amount)` method is similar to `add`, but it only affects the specified field without changing larger fields. For example, rolling `Calendar.MONTH` may only affect the month while keeping the year unchanged.
     ```java
     calendar.roll(Calendar.MONTH, 1); // Rolls the month forward by 1 without affecting the year
     ```

3. **Getting Date Object**
   - You can convert a `Calendar` object to a `Date` object using the `getTime()` method.
     ```java
     Date date = calendar.getTime();
     ```

4. **Setting Time Zone**
   - **Setting a Specific Time Zone**: Use the `setTimeZone(TimeZone tz)` method to set the timezone.
     ```java
     calendar.setTimeZone(TimeZone.getTimeZone("America/New_York"));
     ```

5. **Comparing Dates**
   - Use `before()`, `after()`, or `equals()` to compare two `Calendar` objects.
     ```java
     Calendar otherCalendar = Calendar.getInstance();
     boolean isBefore = calendar.before(otherCalendar);
     boolean isAfter = calendar.after(otherCalendar);
     ```

6. **Clearing Fields**
   - You can clear all or specific fields using the `clear()` method. 
     ```java
     calendar.clear(); // Clears all fields
     calendar.clear(Calendar.DAY_OF_MONTH); // Clears only the day field
     ```

### Example Usage
Here's a simple example that demonstrates using the `Calendar` class to set a date, add days, and retrieve the updated date:

```java
import java.util.Calendar;
import java.text.SimpleDateFormat;

public class CalendarExample {
    public static void main(String[] args) {
        // Create a Calendar instance and set a specific date
        Calendar calendar = Calendar.getInstance();
        calendar.set(Calendar.YEAR, 2023);
        calendar.set(Calendar.MONTH, Calendar.OCTOBER); // October (0-based)
        calendar.set(Calendar.DAY_OF_MONTH, 10);
        
        // Format the date and print it
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        System.out.println("Original date: " + sdf.format(calendar.getTime()));
        
        // Add 10 days to the date
        calendar.add(Calendar.DAY_OF_MONTH, 10);
        System.out.println("After adding 10 days: " + sdf.format(calendar.getTime()));
        
        // Subtract 2 months from the date
        calendar.add(Calendar.MONTH, -2);
        System.out.println("After subtracting 2 months: " + sdf.format(calendar.getTime()));
    }
}
```

### Advantages of Using `Calendar`
- **Date Arithmetic**: Easier date manipulation compared to `Date`.
- **Time Zones and Localization**: Supports time zones and can handle locale-specific date and time formats.
- **Field-Based**: Allows you to modify individual fields like `YEAR`, `MONTH`, etc., directly.

### Drawbacks of `Calendar`
- **Complexity**: The API can be verbose and complicated for simple date operations.
- **Immutability**: Unlike `java.time` classes, `Calendar` is mutable, which may lead to errors if not carefully handled.
- **Deprecated in Favor of `java.time`**: Since Java 8, the `java.time` package offers a more powerful and streamlined approach to date and time handling.

The `java.time` package is generally recommended for new code, but the `Calendar` class remains relevant for legacy applications and offers date manipulation capabilities that can still be useful.


The `roll()` method in the Java `Calendar` class allows you to increment or decrement a specific calendar field (such as month, day, or hour) without affecting other fields. This method is useful when you want to manipulate one component of the date while keeping others constant.

### Characteristics of `roll()` Method
- **Local Adjustments**: `roll()` only affects the specified field, without carrying over into higher fields. For example, rolling the day of the month from the 31st forward by one in a month with 31 days will wrap back to the 1st of that month, rather than advancing to the next month.
- **No Overflow**: If the adjustment would normally cause an overflow into another field, `roll()` wraps around within the same field instead.
- **Positive and Negative Values**: You can roll forward (with positive values) or backward (with negative values) using the method.

### Syntax
```java
void roll(int field, int amount)
```
- `field`: The calendar field to roll, such as `Calendar.DAY_OF_MONTH`, `Calendar.MONTH`, etc.
- `amount`: The number of units to roll. Positive values roll forward, and negative values roll backward.

There is also a simpler version of `roll`:
```java
void roll(int field, boolean up)
```
- `field`: The calendar field to roll.
- `up`: If `true`, rolls forward by one; if `false`, rolls backward by one.

### Example Usage

1. **Rolling Days Without Changing the Month or Year**
   ```java
   import java.util.Calendar;
   import java.text.SimpleDateFormat;

   public class CalendarRollExample {
       public static void main(String[] args) {
           Calendar calendar = Calendar.getInstance();
           calendar.set(2023, Calendar.OCTOBER, 31); // Set date to October 31, 2023

           // Print original date
           SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
           System.out.println("Original Date: " + sdf.format(calendar.getTime()));

           // Roll the day of the month by 1
           calendar.roll(Calendar.DAY_OF_MONTH, 1);
           System.out.println("After rolling day of month by 1: " + sdf.format(calendar.getTime()));
       }
   }
   ```
   Output:
   ```
   Original Date: 2023-10-31
   After rolling day of month by 1: 2023-10-01
   ```
   Here, rolling the day of the month by 1 wraps it back to the start of October, without changing the month.

2. **Rolling the Month Field Without Affecting the Year**
   ```java
   calendar.set(2023, Calendar.DECEMBER, 15); // Set date to December 15, 2023
   System.out.println("Original Date: " + sdf.format(calendar.getTime()));

   // Roll the month by 1
   calendar.roll(Calendar.MONTH, 1);
   System.out.println("After rolling month by 1: " + sdf.format(calendar.getTime()));
   ```
   Output:
   ```
   Original Date: 2023-12-15
   After rolling month by 1: 2023-01-15
   ```
   Here, rolling the month from December to January changes only the month component, without incrementing the year to 2024. 

### Differences Between `add()` and `roll()`
- **`add(int field, int amount)`**: Allows overflow to the next higher field. For example, adding one month to December will change the year as well.
- **`roll(int field, int amount)`**: Restricts changes to the specified field only, wrapping within that field without affecting higher fields.

The `roll()` method is useful when you need to maintain the integrity of higher fields while making cyclic changes to a specific component of the date.


Q - 

private Date date = new Date(100010001000L);
int oneHourInMiliseconds = 3600000;
        date.setTime(date.getTime() + oneHourInMiliseconds);

 Calendar cal = Calendar.getInstance();
        cal.setTime(date);
        cal.roll(Calendar.MONTH, 12);

cal.getTime().toString()

solution - 

In this code snippet, you’re performing a series of operations on a `Date` object and then using a `Calendar` instance to roll the month by 12 months. Let’s go through each step to understand the resulting behavior.

### Step-by-Step Breakdown

1. **Creating a `Date` Object with a Specific Time:**
   ```java
   private Date date = new Date(100010001000L);
   ```
   Here, you’re creating a `Date` object that represents a specific point in time: `100010001000L` milliseconds after January 1, 1970 (the epoch). This sets the date to approximately March 3, 1973.

2. **Adding One Hour to the `Date` Object:**
   ```java
   int oneHourInMiliseconds = 3600000;
   date.setTime(date.getTime() + oneHourInMiliseconds);
   ```
   The code adds one hour (3,600,000 milliseconds) to the `date`. After this, the `Date` object represents March 3, 1973, 05:33:21 GMT. The exact time and date might vary depending on the timezone, but this shows the general calculation.

3. **Converting `Date` to `Calendar`:**
   ```java
   Calendar cal = Calendar.getInstance();
   cal.setTime(date);
   ```
   A `Calendar` instance (`cal`) is created, and it’s set to the date and time held by the `date` object. This provides additional flexibility, allowing you to manipulate individual components such as the month.

4. **Rolling the Month Field by 12 Months:**
   ```java
   cal.roll(Calendar.MONTH, 12);
   ```
   The `roll` method is used to change the `MONTH` field by 12 months. However, since `roll()` only affects the specified field, it does not change the `YEAR` field, even though 12 months typically equals one year. This means that rolling the `MONTH` by 12 has no effect since it wraps back to the same month. The date remains in March 1973.

5. **Getting the Final Date and Printing:**
   ```java
   cal.getTime().toString();
   ```
   The `getTime()` method returns a `Date` object representing the modified date. Since rolling by 12 months wrapped back to March without changing the year, the output will remain close to the initial date, but with an hour added:

   ```
   Sat Mar 03 05:33:21 GMT 1973
   ```

### Key Points
- **Rolling with `Calendar.MONTH` by 12 has No Effect:** Because rolling in this context wraps around without modifying the year, the month remains the same.
- **Differences Between `add()` and `roll()`:** If you had used `add(Calendar.MONTH, 12)` instead of `roll`, the date would move forward by exactly one year to March 1974. In this case, `roll()` preserves the original year by wrapping within the `MONTH` field only.
  
Overall, this code demonstrates how the `roll()` method affects only the specific field without altering higher fields, thus leaving the date effectively unchanged despite rolling by 12 months.


Q - DateFormat - 

The `DateFormat` class in Java is an abstract class used for formatting and parsing dates and times. It provides methods to convert `Date` objects to `String` representations (formatting) and vice versa (parsing). This class is part of the `java.text` package and serves as the base class for specific date/time formatting classes, such as `SimpleDateFormat`.

### Key Features of `DateFormat`
- **Locale-Sensitive:** `DateFormat` can format dates in a locale-sensitive manner, making it useful for applications that require localization.
- **Predefined Styles:** It provides several predefined styles for date and time formats, including `SHORT`, `MEDIUM`, `LONG`, and `FULL`.
- **Thread Safety:** `DateFormat` is not thread-safe. If multiple threads need to format dates simultaneously, it’s best to use separate `DateFormat` instances for each thread or to synchronize access.

### Common Methods in `DateFormat`
1. **`format(Date date)`:** Converts a `Date` object into a formatted `String`.
2. **`parse(String source)`:** Parses a `String` into a `Date` object.
3. **`getDateInstance()`, `getTimeInstance()`, `getDateTimeInstance()`:** Factory methods for obtaining `DateFormat` objects with specific date, time, or date-time styles.
4. **`setTimeZone(TimeZone zone)`:** Sets the time zone to be used for formatting.

### Using `DateFormat` for Formatting
You can create a `DateFormat` object for date, time, or both using the factory methods:

```java
import java.text.DateFormat;
import java.util.Date;
import java.util.Locale;

public class DateFormatExample {
    public static void main(String[] args) {
        // Get the current date
        Date currentDate = new Date();
        
        // Create DateFormat instances with different styles
        DateFormat shortDateFormat = DateFormat.getDateInstance(DateFormat.SHORT);
        DateFormat mediumDateFormat = DateFormat.getDateInstance(DateFormat.MEDIUM);
        DateFormat longDateFormat = DateFormat.getDateInstance(DateFormat.LONG);
        DateFormat fullDateFormat = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);

        // Format the date into different styles
        System.out.println("SHORT: " + shortDateFormat.format(currentDate));
        System.out.println("MEDIUM: " + mediumDateFormat.format(currentDate));
        System.out.println("LONG: " + longDateFormat.format(currentDate));
        System.out.println("FULL (US): " + fullDateFormat.format(currentDate));
    }
}
```

Output:
```
SHORT: 10/12/24
MEDIUM: Oct 12, 2024
LONG: October 12, 2024
FULL (US): Saturday, October 12, 2024
```

### Using `DateFormat` for Parsing
To parse a date string back into a `Date` object, use the `parse()` method. 

```java
try {
    DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.SHORT);
    Date parsedDate = dateFormat.parse("10/12/24");
    System.out.println("Parsed Date: " + parsedDate);
} catch (ParseException e) {
    e.printStackTrace();
}
```

### `SimpleDateFormat` - A More Flexible Option
While `DateFormat` provides basic formatting capabilities, `SimpleDateFormat` offers more control over date and time patterns, such as specifying custom formats.

```java
import java.text.SimpleDateFormat;

SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
String formattedDate = sdf.format(currentDate);
System.out.println("Custom Format: " + formattedDate);
```

Output:
```
Custom Format: 2024-10-12 10:30:45
```

### Important Considerations
- **Time Zones:** `DateFormat` uses the default time zone of the JVM unless a specific time zone is set with `setTimeZone()`.
- **Locale:** Date and time representations can vary by locale. Using `DateFormat` with a specified locale allows for localized formatting.
- **Parsing Exceptions:** The `parse()` method can throw a `ParseException` if the input string cannot be parsed into a `Date`.

In summary, `DateFormat` is a convenient way to handle date and time formatting and parsing in Java, with predefined styles and locale support. For custom patterns, `SimpleDateFormat` is more flexible.


If you call `getDateInstance()` without specifying a format style, `DateFormat` will use the default formatting style for dates, which is the `MEDIUM` style. This default format varies slightly depending on the locale, but it generally includes the abbreviated month name, day of the month, and the full year.

### Example of Using `getDateInstance()` Without a Style
Here’s how the default `MEDIUM` style looks when used without explicitly specifying the format:

```java
import java.text.DateFormat;
import java.util.Date;

public class DefaultDateInstanceExample {
    public static void main(String[] args) {
        // Get the current date
        Date currentDate = new Date();
        
        // Use getDateInstance() with the default format
        DateFormat dateFormat = DateFormat.getDateInstance();
        String formattedDate = dateFormat.format(currentDate);
        
        // Print the formatted date
        System.out.println("Default (MEDIUM) Format: " + formattedDate);
    }
}
```

### Expected Output
Depending on your locale, the output might look like:
```
Default (MEDIUM) Format: Oct 12, 2024
```
In this output, the date is formatted in the `MEDIUM` style by default, which generally includes:
- The abbreviated month name.
- The day of the month as a number.
- The full year.

### Locale-Specific Formatting
The exact appearance of the `MEDIUM` style can vary based on the system’s default locale. If you need a specific locale format, you can pass a locale to `getDateInstance()` like this:
```java
DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.DEFAULT, Locale.FRANCE);
```

So, calling `DateFormat.getDateInstance()` without any arguments defaults to the `MEDIUM` style for date formatting.


Q - 

In this code snippet, you're using the `SimpleDateFormat` class in Java to parse a date string into a `Date` object. Let's break down each part of the code to understand how it works:

### Code Breakdown

1. **Creating a `SimpleDateFormat` Instance:**
   ```java
   DateFormat dateFormat = new SimpleDateFormat("MM-dd-yyyy");
   ```
   - Here, you're creating an instance of `SimpleDateFormat` with a specified pattern `"MM-dd-yyyy"`.
   - The pattern specifies how the date string should be formatted and parsed:
     - **`MM`**: Represents the two-digit month (01 for January, 12 for December).
     - **`dd`**: Represents the two-digit day of the month (01 to 31).
     - **`yyyy`**: Represents the four-digit year (e.g., 2000).

   This means that the `SimpleDateFormat` instance will expect dates in the format of "month-day-year".

2. **Parsing a Date String:**
   ```java
   Date date2 = dateFormat.parse("01-01-2000");
   ```
   - In this line, you're calling the `parse` method of the `dateFormat` instance to convert the string `"01-01-2000"` into a `Date` object.
   - The `parse` method reads the string according to the format defined in the `SimpleDateFormat` instance. In this case, it correctly identifies the components:
     - `01` as the month (January)
     - `01` as the day
     - `2000` as the year
   - The result is that `date2` will now hold a `Date` object representing January 1, 2000.

### Example Code with Error Handling
It's important to note that `parse` can throw a `ParseException` if the input string does not match the expected format. Here's a complete example that includes error handling:

```java
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class DateParsingExample {
    public static void main(String[] args) {
        // Create a SimpleDateFormat instance with the desired format
        DateFormat dateFormat = new SimpleDateFormat("MM-dd-yyyy");

        try {
            // Parse the date string into a Date object
            Date date2 = dateFormat.parse("01-01-2000");
            // Print the parsed date
            System.out.println("Parsed Date: " + date2);
        } catch (ParseException e) {
            // Handle the exception if parsing fails
            e.printStackTrace();
        }
    }
}
```

### Expected Output
If the input string matches the format, you would see an output like:
```
Parsed Date: Sat Jan 01 00:00:00 GMT 2000
```
(Note: The exact output may vary depending on your system's timezone settings.)

### Key Points
- **Date Format Patterns:** The pattern used in `SimpleDateFormat` must match the structure of the date string being parsed.
- **Locale Sensitivity:** `SimpleDateFormat` is not locale-sensitive by default, so you need to ensure that the format specified aligns with the date string format being used.
- **Thread Safety:** `SimpleDateFormat` is not thread-safe. If multiple threads need to format or parse dates, consider using a separate instance for each thread or using synchronization.
- **Error Handling:** Always handle the potential `ParseException` when using `parse()` to avoid crashes due to invalid input.

In summary, this code snippet demonstrates how to use `SimpleDateFormat` to parse a formatted date string into a `Date` object in Java, enabling easy manipulation and formatting of date and time data.



Q - equals method - 

To properly implement the `equals` method for the `Car` class, you need to follow the general contract of the `equals` method defined in the Java documentation. Specifically, you should check if the provided object is the same as the current object, if it is an instance of the `Car` class, and finally compare the relevant fields (in this case, `name` and `horsepower`).

### Implementation of `equals` Method
Here's how you can implement the `equals` method:

```java
@Override
public boolean equals(Object other) {
    // Check if the object is the same as this instance
    if (this == other) {
        return true; // Same reference
    }

    // Check if the other object is an instance of Car
    if (!(other instanceof Car)) {
        return false; // Not the same type
    }

    // Cast other to Car for comparison
    Car otherCar = (Car) other;

    // Compare the fields for equality
    return this.horsepower == otherCar.horsepower && 
           this.name.equals(otherCar.name);
}
```

### Explanation
1. **Identity Check:** The first condition checks if the reference to the current object (`this`) is the same as the reference to the object passed as an argument (`other`). If they are the same, they are equal, and you can return `true`.

2. **Type Check:** The second condition checks if `other` is an instance of the `Car` class. If it's not, you return `false` since you cannot compare objects of different types.

3. **Field Comparison:** After confirming that `other` is of the correct type, you cast it to `Car`. Then, you compare the relevant fields—`horsepower` and `name`. 
   - For `horsepower`, you compare the integer values directly.
   - For `name`, you use the `String` method `equals` to check for value equality. This is important because the `==` operator would compare references for strings.

### Implementation of `hashCode` Method
When you override `equals`, you should also override `hashCode` to maintain the general contract for `hashCode`. Here’s how to implement it:

```java
@Override
public int hashCode() {
    // Use a prime number to calculate hash code based on relevant fields
    int result = 17; // Starting with a non-zero constant
    result = 31 * result + name.hashCode(); // Hash for name
    result = 31 * result + horsepower; // Hash for horsepower
    return result;
}
```

### Explanation of `hashCode`
- You start with a non-zero constant (e.g., 17) to ensure a good distribution of hash codes.
- Multiply the current result by a prime number (e.g., 31) and add the hash code of `name` and the `horsepower` value.
- This implementation ensures that `hashCode` produces consistent results when `equals` returns `true`, as both fields used in `equals` are accounted for in the `hashCode`.

### Complete `Car` Class
Here’s the complete `Car` class with the updated `equals` and `hashCode` methods:

```java
static class Car {
    public String name = "";
    public int horsepower = 0;

    public Car(String s, int p) {
        name = s;
        horsepower = p;
    }

    @Override
    public boolean equals(Object other) {
        if (this == other) {
            return true; // Same reference
        }
        if (!(other instanceof Car)) {
            return false; // Not the same type
        }
        Car otherCar = (Car) other;
        return this.horsepower == otherCar.horsepower && 
               this.name.equals(otherCar.name);
    }

    @Override
    public int hashCode() {
        int result = 17; // Starting with a non-zero constant
        result = 31 * result + name.hashCode(); // Hash for name
        result = 31 * result + horsepower; // Hash for horsepower
        return result;
    }
}
```

This implementation ensures that two `Car` objects with the same `name` and `horsepower` will be considered equal, while also maintaining the consistency required by the `hashCode` method.


Q - null and -1 is the end of the file character.

Q - 

In Java, a static class is a nested (inner) class that is declared with the `static` keyword. Static classes are associated with the outer class rather than instances of the outer class, which means you don’t need to create an instance of the outer class to instantiate a static nested class. They can only access static members (fields and methods) of the outer class directly.

### Key Points About Static Classes
1. **Access to Outer Class Members**: A static nested class can access static members of the outer class but not the non-static members directly.
2. **Instantiation**: Since a static class is associated with the outer class rather than any specific instance, it can be instantiated without creating an instance of the outer class.
3. **Use Cases**: Static classes are commonly used for grouping classes that will be used only in conjunction with their outer class. Examples include utility classes, helper classes, and classes representing part of a larger entity.

### Example of a Static Class
Here’s a basic example to illustrate a static nested class:

```java
public class OuterClass {
    private static String staticMessage = "Hello from OuterClass!";
    
    // Static nested class
    public static class StaticNestedClass {
        public void printMessage() {
            System.out.println(staticMessage);
        }
    }
    
    // Non-static nested (inner) class
    public class InnerClass {
        public void display() {
            System.out.println("Hello from InnerClass!");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        // Instantiating a static nested class
        OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
        nestedObject.printMessage();

        // Instantiating a non-static nested class
        OuterClass outerObject = new OuterClass();
        OuterClass.InnerClass innerObject = outerObject.new InnerClass();
        innerObject.display();
    }
}
```

### Explanation
- **Static Nested Class**: `StaticNestedClass` is a static nested class inside `OuterClass`. You can create an instance of `StaticNestedClass` without needing an instance of `OuterClass`.
- **Non-Static Inner Class**: For comparison, `InnerClass` is a regular inner class, which requires an instance of `OuterClass` to be created.

### How to Instantiate a Static Class
As shown in the example:
```java
OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
```
Since `StaticNestedClass` is static, it can be created directly through the outer class without an outer class instance.

### Common Interview Questions and Answers
Here are some common questions and answers regarding static classes in interviews:

#### Q1. What is a static nested class in Java?
   - **Answer**: A static nested class is a class defined within another class using the `static` keyword. It can be instantiated without an instance of the outer class, and it can access the static members of the outer class directly.

#### Q2. How does a static nested class differ from a non-static nested class (inner class)?
   - **Answer**: A static nested class can be instantiated without an instance of the outer class and only has access to the static members of the outer class. In contrast, a non-static inner class can only be instantiated within an instance of the outer class and can access both static and non-static members of the outer class.

#### Q3. Can a static nested class access non-static members of the outer class?
   - **Answer**: No, a static nested class can only directly access static members of the outer class. It does not have access to non-static members of the outer class because it does not have a reference to an instance of the outer class.

#### Q4. Why would you use a static nested class?
   - **Answer**: A static nested class is useful when you want to logically group a class with another class but do not need a reference to an instance of the outer class. It can help organize code, especially if the nested class is only relevant in the context of the outer class.

#### Q5. How do you instantiate a static nested class?
   - **Answer**: You instantiate a static nested class using the outer class’s name: `OuterClass.StaticNestedClass instance = new OuterClass.StaticNestedClass();`.

#### Q6. What are some common use cases for static nested classes?
   - **Answer**: Static nested classes are often used for utility or helper classes that assist the outer class. They are also used in scenarios where the nested class does not need to interact with instance variables of the outer class, such as for implementing data structures like linked lists or trees within a containing class.

By understanding these concepts and preparing for common questions, you should be well-equipped to discuss static nested classes in Java during an interview.


Q - Locale - 

In Java, a `Locale` is an object that represents a specific geographical, political, or cultural region. It is used to customize the behavior of certain classes based on the user's language, country, or other regional settings. This includes, for example, formatting dates, times, numbers, and currency in a way that aligns with the conventions of a specific locale.

### Key Components of Locale
A `Locale` object consists of three main components:
1. **Language**: A two-letter lowercase ISO 639 code, such as "en" for English or "fr" for French.
2. **Country/Region**: A two-letter uppercase ISO 3166 code, such as "US" for the United States or "FR" for France.
3. **Variant**: An optional value that provides additional differentiation within a language and country. This is often used for different dialects or scripts.

### Creating a Locale
You can create a `Locale` in several ways:
1. Using a constructor with a language code, country code, and variant:
   ```java
   Locale locale = new Locale("en", "US");
   ```
2. Using constants for common locales:
   ```java
   Locale locale = Locale.FRANCE; // French language in France
   ```
3. Using `Locale.Builder` for more complex configurations:
   ```java
   Locale locale = new Locale.Builder().setLanguage("en").setRegion("US").build();
   ```

### Using Locale
The `Locale` class is often used with classes like `DateFormat`, `NumberFormat`, and `ResourceBundle` to provide locale-specific data.

For example, if you want to format a date for a specific locale:
```java
import java.text.DateFormat;
import java.util.Date;
import java.util.Locale;

public class LocaleExample {
    public static void main(String[] args) {
        Locale locale = new Locale("fr", "FR"); // French locale for France
        DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.LONG, locale);
        String formattedDate = dateFormat.format(new Date());
        System.out.println("Date in French format: " + formattedDate);
    }
}
```

### Common Methods in the Locale Class
- **`getLanguage()`**: Returns the language code.
- **`getCountry()`**: Returns the country code.
- **`getDisplayLanguage()`**: Returns the name of the language in the default locale.
- **`getDisplayCountry()`**: Returns the name of the country in the default locale.
- **`getDisplayName()`**: Returns a name for the locale that is appropriate for display to the user.

### Example
Here’s an example that shows how `Locale` can be used to format currency in different regions:

```java
import java.text.NumberFormat;
import java.util.Locale;

public class CurrencyExample {
    public static void main(String[] args) {
        double amount = 12345.67;

        // Format currency in the US locale
        NumberFormat usFormatter = NumberFormat.getCurrencyInstance(Locale.US);
        System.out.println("US: " + usFormatter.format(amount));

        // Format currency in the France locale
        NumberFormat frFormatter = NumberFormat.getCurrencyInstance(Locale.FRANCE);
        System.out.println("France: " + frFormatter.format(amount));
    }
}
```
Output:
```
US: $12,345.67
France: 12 345,67 €
```

### Summary
- **Locale** is used to adapt applications for international use by accommodating language, country, and cultural differences.
- Java provides predefined constants for common locales and allows you to customize locales based on specific language and country codes.
- It is often paired with classes for formatting numbers, dates, and other data types to match local conventions.

By using `Locale`, Java programs can more easily adapt to users in different regions, making them more accessible and user-friendly for an international audience.


Q -  Calendar cal = Calendar.getInstance();
        cal.set(2011, 3, 3);
        Date date = cal.getTime();
        Locale localeBR = new Locale("pt", "BR"); // portuguese, Brazil
        DateFormat dateformatBR = DateFormat.getDateInstance(DateFormat.FULL, localeBR);


This code snippet demonstrates how to use the `Calendar` and `DateFormat` classes in Java to format a date according to a specific locale—in this case, Brazilian Portuguese. Let’s go through each part step-by-step:

### Code Breakdown

1. **Creating a Calendar Instance and Setting a Date**:
   ```java
   Calendar cal = Calendar.getInstance();
   cal.set(2011, 3, 3);
   ```
   - `Calendar.getInstance()` creates a new `Calendar` object set to the current date and time.
   - `cal.set(2011, 3, 3);` sets the calendar to April 3, 2011. Note that months are zero-based, so `3` represents April.

2. **Converting Calendar to Date**:
   ```java
   Date date = cal.getTime();
   ```
   - `cal.getTime()` retrieves the `Date` object that represents the current date and time of the `Calendar` instance.

3. **Creating a Locale for Brazil**:
   ```java
   Locale localeBR = new Locale("pt", "BR");
   ```
   - This line defines a `Locale` object for Brazilian Portuguese. The language code is "pt" for Portuguese, and "BR" is the country code for Brazil.

4. **Formatting the Date for the Brazilian Locale**:
   ```java
   DateFormat dateformatBR = DateFormat.getDateInstance(DateFormat.FULL, localeBR);
   ```
   - `DateFormat.getDateInstance(DateFormat.FULL, localeBR)` creates a `DateFormat` object configured to format dates in a full, localized style for Brazil.
   - `DateFormat.FULL` specifies that the date should be fully formatted, which usually includes the day of the week, date, month, and year.

5. **Formatting the Date**:
   ```java
   String formattedDate = dateformatBR.format(date);
   System.out.println(formattedDate);
   ```
   - You can then format the `Date` object using the `DateFormat` object and print it.

### Expected Output
For the date April 3, 2011, in the `FULL` style and using the Brazilian Portuguese locale, the output will typically look like this:
```
domingo, 3 de abril de 2011
```
In this output:
   - "domingo" is the Portuguese word for Sunday.
   - "3 de abril de 2011" represents the date in the format day, month, year, with prepositions "de" in between, which is typical for Brazilian date formatting.

### Summary
This code snippet uses the `Calendar` class to create a specific date, then formats it according to the conventions of Brazilian Portuguese. The `DateFormat` class, combined with a `Locale`, allows for date formatting that reflects regional settings, making it easy to internationalize applications for various languages and regions.



Q - 

 float someAmount = 442.23f; // Don't use floats for money in real life. Really. It's a bad idea.
        Locale locBR = new Locale("pt", "BR");
        NumberFormat nf = NumberFormat.getCurrencyInstance(locBR);

nf.format(someAmount)


In this code snippet, you're formatting a float value as currency according to Brazilian conventions. Here’s a breakdown of each step:

### Step-by-Step Explanation

1. **Declaring a Float for Currency**:
   ```java
   float someAmount = 442.23f; // Don't use floats for money in real life. Really. It's a bad idea.
   ```
   - A float variable `someAmount` is initialized to `442.23f`.
   - **Important Note**: Using `float` for monetary values is generally discouraged due to precision issues with floating-point arithmetic. `BigDecimal` is preferred for handling money in Java because it avoids rounding errors.

2. **Creating a Brazilian Locale**:
   ```java
   Locale locBR = new Locale("pt", "BR");
   ```
   - This `Locale` object represents Portuguese (`"pt"`) as used in Brazil (`"BR"`).
   - It will be used to format the currency according to Brazilian conventions.

3. **Getting a Currency Formatter**:
   ```java
   NumberFormat nf = NumberFormat.getCurrencyInstance(locBR);
   ```
   - `NumberFormat.getCurrencyInstance(locBR)` returns a `NumberFormat` object configured to format currency values based on the specified locale (in this case, Brazilian currency format).
   - `NumberFormat` automatically adapts the formatting to include the correct currency symbol, decimal separator, and groupings as used in that locale.

4. **Formatting the Amount**:
   ```java
   nf.format(someAmount);
   ```
   - This converts `someAmount` to a `String` that represents the currency in the correct Brazilian format.
   - The `format` method adds the Brazilian Real (R$) symbol, uses a comma as the decimal separator, and includes groupings (if needed).

### Expected Output
With `someAmount` set to `442.23` and the Brazilian locale, the output will look like:
```
R$ 442,23
```

In this output:
- `R$` is the symbol for the Brazilian Real.
- `442` is the amount before the decimal point.
- `,23` represents the fractional part of the currency, where a comma is used as the decimal separator according to Brazilian conventions.

### Summary
The code leverages the `Locale` and `NumberFormat` classes to format a currency value for display based on specific regional settings. This is highly useful for applications that need to handle different currencies and display formats based on users' locations, ensuring the correct currency symbol and separators are used for a given locale.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------




POSTGRES - 

1. Create DB, permissions etc.
Write a SQL script that creates a new user, and database. Make the user the owner of the db.

Solution - 

-- creating the user
CREATE USER dj WITH PASSWORD '2151';

-- creating new database
CREATE DATABASE ipl_data_project;

-- assigining the user owner permissions
ALTER DATABASE ipl_data_project OWNER to dj;

-- giving the user all the permissions for the database ipl_data_project
GRANT ALL PRIVILEGES ON DATABASE ipl_data_project to dj;


2. Clean up script
Write another SQL script that cleans up the user, and database created in the previous step.

Solution - 

-- deleting the database
DROP DATABASE IF EXISTS ipl_data_project;

--  deleting the user from the server
DROP USER IF EXISTS dj;




3. Load CSV
Write a SQL script that loads CSV data into a table.

Loading the deliveries data - 

CREATE TABLE deliveries (
    match_id INT,
    inning INT,
    batting_team VARCHAR(255),
    bowling_team VARCHAR(255),
    over INT,
    ball INT,
    batsman VARCHAR(255),
    non_striker VARCHAR(255),
    bowler VARCHAR(255),
    is_super_over INT,
    wide_runs INT,
    bye_runs INT,
    legbye_runs INT,
    noball_runs INT,
    penalty_runs INT,
    batsman_runs INT,
    extra_runs INT,
    total_runs INT,
    player_dismissed VARCHAR(255),
    dismissal_kind VARCHAR(255),
    fielder VARCHAR(255)
);


COPY deliveries(match_id, inning, batting_team, bowling_team, over, ball, batsman, non_striker, bowler, is_super_over, wide_runs, bye_runs, legbye_runs, noball_runs, penalty_runs, batsman_runs, extra_runs, total_runs, player_dismissed, dismissal_kind, fielder)
FROM '/home/dj/Downloads/deliveries.csv'
DELIMITER ','
CSV HEADER;

SELECT * FROM deliveries LIMIT 10;


loading the matches data - 


CREATE TABLE matches (
    id SERIAL PRIMARY KEY,
    season INT,
    city VARCHAR(255),
    date DATE,
    team1 VARCHAR(255),
    team2 VARCHAR(255),
    toss_winner VARCHAR(255),
    toss_decision VARCHAR(10),
    result VARCHAR(10),
    dl_applied BOOLEAN,
    winner VARCHAR(255),
    win_by_runs INT,
    win_by_wickets INT,
    player_of_match VARCHAR(255),
    venue VARCHAR(255),
    umpire1 VARCHAR(255),
    umpire2 VARCHAR(255),
    umpire3 VARCHAR(255)
);


COPY matches(id, season, city, date, team1, team2, toss_winner, toss_decision, result, dl_applied, winner, win_by_runs, win_by_wickets, player_of_match, venue, umpire1, umpire2, umpire3)
FROM '/home/dj/Downloads/matches.csv'
DELIMITER ','
CSV HEADER;

SELECT * FROM matches LIMIT 10;



------------------------------------------------------------------------------------------------------------


what is junit - 
It is an popular java testing framework used for unit testing. its purpose is to provide a standardized way to write and execute test cases, ensuring that each individual unit of code functions correctly in isolation.

feature of junit -

Annotaions based test cases definations
Assertions for verifying expected results.
support for organizing and running test suites.
Test fixtures to set up pre conditions and clean up after tests with , BeforeAll, BeforeEach, AfterEach, AfterAll.

Parameterized test to run the same test with different inputs. Test runners to customize the test execution behaviour.

How to annotate a method as Junit test case -

To annotation a method as a junit test case we need to use the @Test annotation provided by junit. add @Test annotation above the method 
declaration and junit will recognize it as a test case and execute it.

Lifecycle of Junit test case - 

The lifecycle of the junit test case typically consists of the below phases - 
Setup - any necessary preconditions are set up, such as initilizing objects fo configuring the environment.

Execution - The actual test case code is executed.

Assertion - the expected results are verified using assertions.
Teardown - Any resources or temporary data used during the test are cleaned up to ensure a clean state of the next test.

How to write the parameterized test in junit - 
It allows you to write parameterized tests using the @ParameterizedTest and @ValueSource annotations. the @ValueSource annotation specifies the values to be used as test inputs and junit automatically runs the test multiple times with each value.

What is the purpose of the @RunWith annotation in junit - 

It is used in Junit to specify  a custom test runner for executing tests. It allows you to extend or replace the default junit test runner with a custom implementation. 


what is the purpose of @BEforeEach and @AfterEach annotaion in junit - 

The @BeforeEach and @AfterEach annotations are used to define methods that run before and after each individual teset method, respectively. they are used for setting up and tearing down the test environment or any common test fixtures that need to be initialized or cleaned up for each test.


how to mock depedencies in junit tests?

In tests , we can mock the depedencies using mocking frameworks such as mockito. this framework allows us to create mock objects that simulate the behaviour of the real dependenciws. By mocking dependencies, you can isolate the unit under test and focus on testing its specific behaviour without involving the actual dependencies.

How do you test private methods in junit - 
In general, junit focuses on testing public methods, as they are the primary interface to the class under test. Hoever, if you want to test the private methods, there are a few approaches - 

Refactor the code
Use Reflection
Test through public methods.


best practices for writing the tests in junit - 
Write small, focused test methods that test a single piece of functionality. use meaningful test methods and test class names to describe the behaviour being tested.

set up the necessary test data and fixtures using the @Before and @BeforeEach annotations.
Using assertions to validate the expected results.
keeping tests independant and avoiding dependencies between test methods. Adding descriptive comments to explain the purpose and behaviour of the test. running tests frequently and ensuring they are always passing. Refactoring test code to improve readability and maintainability.

write tests for both positive and negative scenarios. consider performance and edge cases when desigining tests. 

following the arrange-act-assert pattern for test method structure. write the self contained test that do not rely on external resources or dependencies.



---------

	
Session 3 - 

	




	
	


JSON / XML schema validation - 


	
-------------------------

put the timer of 25 mins if you could not solve in this time then go for hints and solution.

and put this question in the bookmark tab, do like this from monday to saturday. and on sunday go through the bookmarked questions, see if you can solve it in the 25 mins. if able to  then remove it from the bookmark, like this on sunday your no of bookmarked questions should reduce.


Get your resume reviewed by the seniors at the scaler.

Start giving interviews now.


observe your time - prepare the excel sheet and log the details what are you doing in that hour. rows should have time and columns should have dates.

Easy questions are the foundation.

20 % easy and 20 % hard questions and solve 60 %% medium questions.

for hard do the very popular questions.

first try to do the brute force solution first and then see if you can optimize it.

atleast try to solve one question a day.

Dream high even there is no chance for it now, eventually you will land there.

plan your day ahead of time.

also try to focus for 25 minutes for the company tasks also.

--------

Pomodoro Technique
The Pomodoro Technique is a time-management method that breaks down work into intervals, usually 25 minutes long, separated by 5-minute breaks. After four intervals (also known as "Pomodoros"), you take a longer break, usually around 15–30 minutes. This approach helps maintain focus and prevents burnout.

How to Implement the Pomodoro Technique:
Choose a Task: Pick a task or list of tasks to focus on.
Set a Timer for 25 Minutes: This is your focused work period. During this time, try to eliminate all distractions.
Work Until the Timer Rings: Concentrate solely on your task without interruptions.
Take a 5-Minute Break: Step away from your work to recharge. Stretch, grab a snack, or rest your eyes.
Repeat: After completing four Pomodoros, take a longer break to rest your mind.
Benefits:
Enhanced Focus: Short bursts of focused work can help reduce mental fatigue.
Improved Time Awareness: The timed intervals create urgency and encourage better time management.
Reduced Procrastination: Setting a clear start and end time for each Pomodoro reduces procrastination and helps with task completion.
Tools to Get Started:
Apps: Forest, Focus Booster, and Pomodone are popular apps for managing Pomodoro sessions.
Physical Timers: A simple kitchen timer or an hourglass can also work effectively.
Spaced Repetition Technique
Spaced Repetition is a learning technique based on the idea that we retain information better when it is reviewed over increasing intervals of time, rather than all at once. It leverages the "spacing effect" to strengthen memory by revisiting information before it is forgotten.

How to Implement Spaced Repetition:
Break Down Information: Start with flashcards or notes on individual concepts.
Set Review Intervals: Schedule reviews of each concept over time. Common intervals are 1 day, 3 days, 7 days, and 14 days, with gradually increasing gaps.
Test Yourself Regularly: Self-quizzing during each review session helps strengthen recall.
Adjust Based on Retention: If you find something easy, you can extend the interval. If something’s hard, review it more frequently.
Benefits:
Long-Term Retention: Information reviewed with spacing is more likely to be remembered over the long term.
Efficient Learning: Spacing out reviews saves time compared to cramming.
Memory Strengthening: The technique reinforces neural pathways, making information easier to recall.
Tools to Get Started:
Anki: This app allows you to create flashcards and uses an algorithm to determine optimal review times.
Quizlet: Another app with spaced repetition options for learning with flashcards.
Combining Both Techniques
For even more effective learning, consider combining Pomodoro for focused study periods with Spaced Repetition for information retention:

Use the Pomodoro Technique to work through learning materials in focused intervals.
Integrate Spaced Repetition within each Pomodoro to review past materials.
Set up flashcards or notes in an app like Anki or Quizlet, and use Pomodoros to go through these cards in intervals.
By using both techniques, you can enhance productivity while retaining knowledge more effectively over time.



------------------------



Authentication and authorization - 

Authentication  - in this where user is valid or not is checked. 

Authorization - in this the permissions or access levels of the user are checked.

Authentication types - Basic, Digest, Preempive, Bearertoken, OAuth 1.0, 2.0, API key.


Basic authentication- 

@Test
	void BasicAuth() {
		
		given()
			.auth().basic("postman","password")
		.when()
			.get("https://postman-echo.com/basic-auth")
		.then()
			.statusCode(200)
			.body("authenticated", equalTo(true))
			.log().all();
			
	}
	
	
Digest Authentication -
	
	@Test
	void DigestAuth() {
		
		given()
			.auth().digest("postman","password")
		.when()
			.get("https://postman-echo.com/basic-auth")
		.then()
			.statusCode(200)
			.body("authenticated", equalTo(true))
			.log().all();
			
	}

Preemptive authentication - 

	@Test
	void preemptiveAuth() {
		
		given()
			.auth().preemptive().basic("postman","password")
		.when()
			.get("https://postman-echo.com/basic-auth")
		.then()
			.statusCode(200)
			.body("authenticated", equalTo(true))
			.log().all();
			
	}

Bearer token - 

@Test
	void bearerTokenAuth() {
		
		String bearerToken = "askdfjhasdgfklhdghafotwrajnf_asdfkhasdjf_gsdfrgoier";
		

		
		given()
			.headers("Authorization","Bearer "+bearerToken)
		.when()
			.get("https://api.github.com/users/repos")
		.then()
			.statusCode(200)
			.log().all();
	}
	

OAuth1 - 

in this four fields will be given to us like consumerKey, consumerSecret, accessToken, tokenSecrete.

	@Test
	void testOAuth1() {
		String consumerKey = "dummyConsumerKey123";
		String consumerSecret = "dummyConsumerSecret456";
		String accessToken = "dummyAccessToken789";
		String tokenSecret = "dummyTokenSecret012";
		
		
		given()
			.auth().oauth(consumerKey, consumerSecret, accessToken, tokenSecret)
			
			.when()
				.get("some url")
			.then()
				.statusCode(200)
				.log().all();
	

	}
	
	
OAuth2 - 

@Test
	void testOAuth2() {
		String oAuth2Token = "SomeRandomTokenValue";
		
		
		given()
			.auth().oauth2(oAuth2Token)
			
			.when()
				.get("some url")
			.then()
				.statusCode(200)
				.log().all();
	

	}
	
	
API key authentication - 

In this the key and value are passed to the server.

method 1 - 

	@Test
	void testAPIKey() {
		
		given()
			.queryParam("apikey", "SomeRandomAPIKeyToAccessTheResource")
		.when()
			.get("api.openweather.com/data/2.5/forecast/daily?q=Delhi&units=metric&cnt=7")
		.then()
			.statusCode(200)
			.log().all();
	}

method 2 - 

	@Test
	void testAPIKeyMethod2() {
		
		given()
			.queryParam("apikey", "SomeRandomAPIKeyToAccessTheResource")
			.pathParam("myPath", "data/2.5/forecast/daily")
			.queryParam("q", "Delhi")
			.queryParam("units", "metric")
			.queryParam("cnt", 7)
		.when()
			.get("api.openweather.com/{myPath}")
		.then()
			.statusCode(200)
			.log().all();
	}
	
	
Faker library - by using this library we can get the dummy data for testing.

add below dependancy - 

<!-- https://mvnrepository.com/artifact/com.github.javafaker/javafaker -->
<dependency>
    <groupId>com.github.javafaker</groupId>
    <artifactId>javafaker</artifactId>
    <version>1.0.2</version>
</dependency>



	@Test
	void generateTestDummyData() {
		Faker faker = new Faker();
		
		String fullName = faker.name().fullName();
		String firstName = faker.name().firstName();
		String lastName = faker.name().lastName();
		String username = faker.name().username();
		String password = faker.internet().password();
		
		String phoneNo = faker.phoneNumber().cellPhone();
		String email = faker.internet().safeEmailAddress();
		String creditCardNo = faker.business().creditCardNumber();
		
		System.out.println(fullName);
		System.out.println(email);
	}
	
	

entire code - 

package org.restassured;

import org.testng.annotations.Test;

import com.github.javafaker.Faker;

public class FakerDataGenerator {

	@Test
	void generateTestDummyData() {
		Faker faker = new Faker();
		
		String fullName = faker.name().fullName();
		String firstName = faker.name().firstName();
		String lastName = faker.name().lastName();
		String username = faker.name().username();
		String password = faker.internet().password();
		
		String phoneNo = faker.phoneNumber().cellPhone();
		String email = faker.internet().safeEmailAddress();
		String creditCardNo = faker.business().creditCardNumber();
		
		System.out.println(fullName);
		System.out.println(email);
	}
}


JSON array and JSON object -

In JSON (JavaScript Object Notation), there are two fundamental structures: **JSON objects** and **JSON arrays**. These allow JSON to represent complex data in a format that is both human-readable and machine-readable.

 1. JSON Object
A JSON object is a collection of key-value pairs, where each key is a string and the value can be a string, number, boolean, null, array, or another object. JSON objects are enclosed in curly braces `{ }`.

 Structure
- **Key-Value Pairs**: Each item in a JSON object has a key and a value.
- **Syntax**: `{ "key1": value1, "key2": value2, ... }`
- **Key**: The key must be a string.
- **Value**: The value can be various data types (string, number, object, array, boolean, or null).

 Example of a JSON Object

{
  "name": "Alice",
  "age": 30,
  "isStudent": false,
  "address": {
    "street": "123 Main St",
    "city": "Springfield",
    "postalCode": "12345"
  },
  "phoneNumbers": ["123-456-7890", "098-765-4321"]
}
```

In this example:
- **"name"** is a string.
- **"age"** is a number.
- **"isStudent"** is a boolean.
- **"address"** is another JSON object.
- **"phoneNumbers"** is a JSON array.

### 2. JSON Array
A JSON array is an ordered list of values. These values can be strings, numbers, booleans, nulls, objects, or other arrays. JSON arrays are enclosed in square brackets `[ ]`.

#### Structure
- **Ordered List**: JSON arrays maintain the order of their elements.
- **Syntax**: `[value1, value2, ...]`
- **Values**: Values can be of any JSON data type, including nested arrays and objects.

#### Example of a JSON Array
```json
[
  "Apple",
  "Banana",
  "Cherry"
]
```

In this case, the JSON array contains three strings.

### Nested JSON Array Example
JSON arrays can also contain objects or even other arrays as elements, allowing for complex data structures.

```json
[
  {
    "name": "Alice",
    "age": 30
  },
  {
    "name": "Bob",
    "age": 25
  },
  {
    "name": "Charlie",
    "age": 35
  }
]
```

In this example, the JSON array contains three JSON objects, each representing a person with `"name"` and `"age"` fields.

### JSON Object vs. JSON Array Summary
- **JSON Object**: A collection of key-value pairs, best used for representing structured data (like an entity with properties).
- **JSON Array**: An ordered list of values, best used for collections of items (like a list of users or products). 

JSON objects and arrays can be combined to represent complex data structures, making JSON a versatile data interchange format widely used in web APIs and applications.




Testing chaining - 

in this first test will be executed and then next test will be executed like this we will perform test one by one and we will share the output of one test to the next test.


in below example I am testing the createUser, GetUser, UpdateUser, DeleteUser functionalities.


for each test case i have created seperate class because in the same class we can test this kind of scenario.

and in this i am using ITestContext to share the data between different classes and tests.

ITestContext is used to share the data between the tests.


CreateUser class - 

package org.restassured.chaining;

import org.testng.annotations.Test;
import org.testng.ITestContext;
import org.testng.annotations.Test;

import com.github.javafaker.Faker;

import io.restassured.response.Response;
import net.minidev.json.JSONObject;

import static io.restassured.RestAssured.*;
import static io.restassured.matcher.RestAssuredMatchers.*;
import static org.hamcrest.Matchers.*;

public class CreateUser {

	
	@Test
	void testSignUp(ITestContext context) {
		
		Faker faker = new Faker();
		
		JSONObject data = new JSONObject();
		data.put("name", faker.name().firstName());
		data.put("gender", "female");
		data.put("email", faker.internet().emailAddress());
		data.put("status", "inactive");
		
		String bearerToken = "thisIsSomeRandomBearerToken";
		
		
		int id = given()
			.header("Authorization", "Bearer " +bearerToken )
			.contentType("application/json")
			.body(data.toString())
		.when()
			.post("https://gorest.co.in/public/v2/users")
			.jsonPath().getInt("id");
		
		context.setAttribute("user_Id", id);
	}
	
}

GetUser.java - 


package org.restassured.chaining;

import org.testng.annotations.Test;
import static io.restassured.RestAssured.given;

import org.testng.ITestContext;
import org.testng.annotations.Test;

import com.github.javafaker.Faker;

import net.minidev.json.JSONObject;

public class GetUser {
	
	@Test
	void testGetUser(ITestContext context) {
				
		String bearerToken = "thisIsSomeRandomBearerToken";
		
			
		int id =(int) context.getAttribute("user_Id");
		
		given()
			.header("Authorization", "Bearer " +bearerToken )
			.pathParam("id", id)

		.when()
			.get("https://gorest.co.in/public/v2/users/{id}")
		.then()
			.statusCode(200)
			.log().all();
			
		
		
	}

}



UpdateUser.java - 

package org.restassured.chaining;

import org.testng.annotations.Test;
import static io.restassured.RestAssured.given;

import org.testng.ITestContext;
import org.testng.annotations.Test;

import com.github.javafaker.Faker;

import net.minidev.json.JSONObject;
import static io.restassured.RestAssured.*;
import static io.restassured.matcher.RestAssuredMatchers.*;
import static org.hamcrest.Matchers.*;



public class UpdateUser {
	
	
	@Test
	void testUpdateUser(ITestContext context) {
		
		Faker faker = new Faker();
		
		JSONObject data = new JSONObject();
		data.put("name", faker.name().firstName());
		data.put("gender", "male");
		data.put("email", faker.internet().emailAddress());
		data.put("status", "active");
		
		String bearerToken = "thisIsSomeRandomBearerToken";
		
		int id =(int) context.getAttribute("user_Id");
		
		 given()
			.header("Authorization", "Bearer " +bearerToken )
			.contentType("application/json")
			.body(data.toString())
			.pathParam("id", id)
		.when()
			.put("https://gorest.co.in/public/v2/users/{id}")
		.then()
			.statusCode(203)
			.log().all();
		
		
	}
	

}

DeleteUser.java - 

package org.restassured.chaining;

import org.testng.annotations.Test;
import static io.restassured.RestAssured.given;

import org.testng.ITestContext;
import org.testng.annotations.Test;
import static io.restassured.RestAssured.*;
import static io.restassured.matcher.RestAssuredMatchers.*;
import static org.hamcrest.Matchers.*;


public class DeleteUser {
	
	@Test
	void testGetUser(ITestContext context) {
				
		String bearerToken = "thisIsSomeRandomBearerToken";
		
			
		int id =(int) context.getAttribute("user_Id");
		
		given()
			.header("Authorization", "Bearer " +bearerToken )
			.pathParam("id", id)
		.when()
			.delete("https://gorest.co.in/public/v2/users/{id}")
		.then()
			.statusCode(204)
			.log().all();
			
		
		
	}

}

now all these files are created in the same package. we will run this by using the testng xml configuration file.


to create the testng xml file, right click on the package in which all these files are created and then select testNG option then select "Convert To TestNG" this will create the xml file which has informatoin about the classes. 

testng.xml - 

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd">
<suite name="Suite">
  <test thread-count="5" name="Test">
    <classes>
      <class name="org.restassured.chaining.CreateUser"/>
      <class name="org.restassured.chaining.GetUser"/>
      <class name="org.restassured.chaining.UpdateUser"/>
      <class name="org.restassured.chaining.DeleteUser"/>
    </classes>
  </test> <!-- Test -->
</suite> <!-- Suite -->



in above file make sure the classes names order should be same as we want it to run.

now run this testng.xml file as a testng test suit, it will run all the test cases one by one and print the result on the console.


In this all the classes are running as a part of the one single test, we can do this to run it in different tests, update the testng.xml like below - 

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd">
<suite name="Suite">
  <test  name="Test1">
    <classes>
      <class name="org.restassured.chaining.CreateUser"/>
    </classes>
  </test> 
  
   <test  name="Test2">
    <classes>

      <class name="org.restassured.chaining.GetUser"/>

    </classes>
  </test> 
  
   <test  name="Test3">
    <classes>

      <class name="org.restassured.chaining.UpdateUser"/>

    </classes>
  </test> 
  
   <test name="Test4">
    <classes>
      <class name="org.restassured.chaining.DeleteUser"/>
    </classes>
  </test> 
  
  
</suite> <!-- Suite -->



but to run like this, context will be different for different tests so it will not share the data as expected. 

for that we need to use the contest of the suite and then it will share the date as expected.

change below to -

context.setAttribute("user_id", id);

to 

context.getSuite().setAttribute("user_id", id);


and update the getting attribute value to below - 

int id =(int) context.getSuite().getAttribute("user_Id");

updated classes - 

CreateUser.java - 


package org.restassured.chaining;

import org.testng.annotations.Test;
import org.testng.ITestContext;
import org.testng.annotations.Test;

import com.github.javafaker.Faker;

import io.restassured.response.Response;
import net.minidev.json.JSONObject;

import static io.restassured.RestAssured.*;
import static io.restassured.matcher.RestAssuredMatchers.*;
import static org.hamcrest.Matchers.*;

public class CreateUser {

	
	@Test
	void testSignUp(ITestContext context) {
		
		Faker faker = new Faker();
		
		JSONObject data = new JSONObject();
		data.put("name", faker.name().firstName());
		data.put("gender", "female");
		data.put("email", faker.internet().emailAddress());
		data.put("status", "inactive");
		
		String bearerToken = "thisIsSomeRandomBearerToken";
		
		
		int id = given()
			.header("Authorization", "Bearer " +bearerToken )
			.contentType("application/json")
			.body(data.toString())
		.when()
			.post("https://gorest.co.in/public/v2/users")
			.jsonPath().getInt("id");
		
		context.getSuite().setAttribute("user_Id", id);
	}
	
}

GetUser.java - 

package org.restassured.chaining;

import org.testng.annotations.Test;
import static io.restassured.RestAssured.given;

import org.testng.ITestContext;
import org.testng.annotations.Test;

import com.github.javafaker.Faker;

import net.minidev.json.JSONObject;

public class GetUser {
	
	@Test
	void testGetUser(ITestContext context) {
				
		String bearerToken = "thisIsSomeRandomBearerToken";
		
			
		int id =(int) context.getSuite().getAttribute("user_Id");
		
		given()
			.header("Authorization", "Bearer " +bearerToken )
			.pathParam("id", id)

		.when()
			.get("https://gorest.co.in/public/v2/users/{id}")
		.then()
			.statusCode(200)
			.log().all();
			
		
		
	}

}


UpdateUser.java - 

package org.restassured.chaining;

import org.testng.annotations.Test;
import static io.restassured.RestAssured.given;

import org.testng.ITestContext;
import org.testng.annotations.Test;

import com.github.javafaker.Faker;

import net.minidev.json.JSONObject;
import static io.restassured.RestAssured.*;
import static io.restassured.matcher.RestAssuredMatchers.*;
import static org.hamcrest.Matchers.*;



public class UpdateUser {
	
	
	@Test
	void testUpdateUser(ITestContext context) {
		
		Faker faker = new Faker();
		
		JSONObject data = new JSONObject();
		data.put("name", faker.name().firstName());
		data.put("gender", "male");
		data.put("email", faker.internet().emailAddress());
		data.put("status", "active");
		
		String bearerToken = "thisIsSomeRandomBearerToken";
		
		int id =(int) context.getSuite().getAttribute("user_Id");
		
		 given()
			.header("Authorization", "Bearer " +bearerToken )
			.contentType("application/json")
			.body(data.toString())
			.pathParam("id", id)
		.when()
			.put("https://gorest.co.in/public/v2/users/{id}")
		.then()
			.statusCode(203)
			.log().all();
		
		
	}
	

}


DeleteUser.java - 

package org.restassured.chaining;

import org.testng.annotations.Test;
import static io.restassured.RestAssured.given;

import org.testng.ITestContext;
import org.testng.annotations.Test;
import static io.restassured.RestAssured.*;
import static io.restassured.matcher.RestAssuredMatchers.*;
import static org.hamcrest.Matchers.*;


public class DeleteUser {
	
	@Test
	void testGetUser(ITestContext context) {
				
		String bearerToken = "thisIsSomeRandomBearerToken";
		
			
		int id =(int) context.getSuite().getAttribute("user_Id");
		
		given()
			.header("Authorization", "Bearer " +bearerToken )
			.pathParam("id", id)
		.when()
			.delete("https://gorest.co.in/public/v2/users/{id}")
		.then()
			.statusCode(204)
			.log().all();
			
		
		
	}

}


now click on the new xml file and re run the tests, it will run successfully.


we can also run previuos xml test file it will still work for this new context configuration.



Framework development - Maintain all project related files.

Objective of this is - 

Reusability 
Maintainability
Readibility

phases of developing the automation framework - 

1) understand the requirement - 
functional requirement
swagger documentation

2) Choose automation tool - 
like Rest Assured library

3) Desing 

4) develop

5) Execution + continuous integration



Rest assured framework design - 


The image shows a detailed framework design for API testing using Rest Assured, TestNG, and other supporting components integrated with CI/CD tools like Git, GitHub, and Jenkins. Here’s a breakdown of each section and the overall flow:

### 1. **Development Layer**
   - This layer contains the core components necessary for test case development in the Rest Assured framework. 

   **Components in Development Layer**:
   
   - **Endpoints**: Defines the routes or endpoints for the API being tested.
     - `UserEndPoints`: Contains the URL paths for user-related APIs (e.g., creating a user, retrieving user details).
     - `StoreEndPoints`: Holds endpoints related to store operations (e.g., order management).
     - `PetEndPoints`: Holds endpoints for pet-related operations.
   
   - **Payloads (POJO)**: Plain Old Java Objects (POJO) are used to create structured data (payloads) for requests. Each POJO represents an entity:
     - `User`: Data structure for a user entity.
     - `Store`: Data structure for store-related information.
     - `Pet`: Data structure for pet-related information.
   
   - **Utilities**: Contains helper classes and tools to support the test execution.
     - `DataProviders`: Provides data to test cases, often used for data-driven testing with different input sets.
     - `Extent Report`: A utility for generating structured reports of test results.
     - `XL Utility`: Utility to read/write data from Excel files, useful for fetching test data dynamically.
   
   - **Test Data**: Stores data files (Excel files) for various test cases.
     - `UserData.xlsx`: Test data for user-related tests.
     - `StoreData.xlsx`: Test data for store-related tests.
     - `PetData.xlsx`: Test data for pet-related tests.

### 2. **Execution Layer**
   - This layer defines the execution and management of test cases using `TestNG` and `pom.xml`.

   **Components in Execution Layer**:
   
   - **Test Cases**: Contains the actual test cases structured by types of operations.
     - `User Tests`: Tests for user-related endpoints (like creating, updating, or deleting users).
     - `Store Tests`: Tests for store-related endpoints (like managing orders).
     - `Pet Tests`: Tests for pet-related endpoints.
   
   - **TestNG.XML**: A configuration file for TestNG, specifying the test suite and test case order. It provides a way to organize and manage test cases, setting up the execution sequence and grouping tests for parallel or sequential execution.
   
   - **pom.xml**: The Maven Project Object Model (POM) file defines project dependencies and plugins required for the framework to work. It includes libraries such as Rest Assured, TestNG, reporting tools, and any other utility libraries.
   
   - **Reports**: Contains generated reports after test execution.
     - `TestNG Reports`: Reports generated by TestNG to summarize test execution results.
     - `Extent Reports`: Customizable and detailed reports generated with the Extent reporting library, providing insights into test status and results.

### 3. **Continuous Integration (CI) Layer**
   - This layer integrates with version control (Git, GitHub) and CI/CD (Jenkins) tools.

   **Components in CI Layer**:
   
   - **Git**: Version control system to track changes in the codebase, enabling team collaboration. Code changes, including new test cases or updates, are committed to Git.
   
   - **GitHub**: A cloud-based platform for hosting Git repositories. The test automation project is stored on GitHub, facilitating easy collaboration and version tracking.
   
   - **Jenkins**: A CI/CD tool that automatically triggers the test execution when changes are pushed to GitHub. Jenkins pulls the code from GitHub, builds it, runs the tests, and generates reports. This automation ensures that any new code is immediately tested, providing fast feedback on code quality.

### Overall Flow

1. **Development**:
   - Developers create test cases and utility files in the development environment.
   - Endpoints and payloads are defined, and utilities are built to support test data management, reporting, etc.
   - Test data is prepared in Excel files, and each test case is configured to use these data files for data-driven testing.

2. **Test Execution**:
   - Using `TestNG.xml`, tests are triggered, which run test cases defined in `Test Cases` with data from `Test Data`.
   - Dependencies and plugins are managed through `pom.xml`, ensuring that all necessary libraries are available.
   - Reports are generated using TestNG’s default reporting or Extent Reports for enhanced visualization.

3. **Continuous Integration**:
   - Code is committed to Git and pushed to GitHub.
   - Jenkins detects new commits, pulls the latest code from GitHub, and triggers the build and test process.
   - Jenkins executes the tests using TestNG, generates reports, and provides feedback on the build status, highlighting any failed tests or issues.

### Summary

This design automates API testing using Rest Assured with support from TestNG and Extent reporting. It integrates with Git and Jenkins to provide a continuous testing solution that can be triggered with every code change, ensuring consistent quality and stability in the API services.



RestAssured framework design 2 - 

The new diagram adds more detail to the test automation framework by introducing a "Properties" component and better organizing the execution flow. Here’s an analysis of the updated structure and how it differs from the previous one:

---

### 1. **Development Layer**
   - **Properties**: 
     - **routes.properties**: This file contains the API routes or base URLs for different environments (e.g., staging, production). It centralizes the URL configurations, making it easier to switch between environments without modifying the code.
   
   - **Endpoints**: Defines specific API routes for each service.
     - Unchanged from the previous version, with `UserEndPoints`, `StoreEndPoints`, and `PetEndPoints` still managing endpoint paths.

   - **Payloads (POJO)**:
     - Contains POJOs for structured payloads for each entity type (`User`, `Store`, `Pet`). No changes here, but now they rely on the `routes.properties` file to define base URLs, enhancing reusability.
   
   - **Utilities**:
     - Includes `DataProviders`, `Extent Report`, and `XL Utility`. These utilities support test execution by providing data, generating reports, and managing test data from Excel.
     - Similar to the previous version, but with a clearer distinction of its role in supporting the test cases.

   - **Test Data**:
     - Contains Excel files (`UserData.xlsx`, `StoreData.xlsx`, `PetData.xlsx`) that store test data for data-driven testing.
     - This component remains the same.

### 2. **Execution Layer**
   - **Test Cases**:
     - Houses individual tests organized by type (`User Tests`, `Store Tests`, `Pet Tests`). These tests now potentially use `routes.properties` for dynamically setting API base URLs, making tests environment-independent.
   
   - **TestNG.XML**:
     - A configuration file for organizing and managing test execution flow with TestNG.
     - Serves the same purpose as before but is now more organized with a dependency on `routes.properties`.

   - **pom.xml**:
     - Defines dependencies and plugins (like Rest Assured, TestNG, and reporting libraries). It remains unchanged in purpose and function.
   
   - **Reports**:
     - Contains `TestNG Reports` and `Extent Reports` for test results.
     - Similar to the previous version but now reflects more structured reporting.

### 3. **Continuous Integration (CI) Layer**
   - **Git, GitHub, Jenkins**:
     - Unchanged from the previous version, with Git for version control, GitHub for hosting the repository, and Jenkins for CI/CD.
     - Jenkins uses this setup to automatically pull code, run tests, and generate reports whenever code is pushed to GitHub.

### Key Differences from the Previous Diagram

1. **Properties File (`routes.properties`)**:
   - The introduction of `routes.properties` adds flexibility, enabling different environments for testing (like staging or production) without modifying the code. This makes the framework more robust and adaptable to changes in API URLs.

2. **Organized Execution Flow**:
   - The updated structure visually organizes the development, execution, and CI components more distinctly, helping to clarify the flow from development to CI/CD integration.

3. **Enhanced Modularity**:
   - By centralizing URL configurations in `routes.properties`, the new design enhances modularity. Test cases and POJOs are now decoupled from environment-specific configurations, promoting easier maintenance.

---

### Summary

The updated design is more modular and organized, with the addition of a `routes.properties` file for environment-specific configuration. This improvement enhances the framework’s flexibility, allowing it to adapt more easily to different environments and changes in base URLs. The diagram layout is clearer, with distinct boundaries between the development, execution, and CI layers.





Project - 

Create simple maven project.
add required dependencies to the pom.xml


add below dependencies to the pom.xml -


<dependencies>


<!-- https://mvnrepository.com/artifact/com.github.javafaker/javafaker -->
<dependency>
    <groupId>com.github.javafaker</groupId>
    <artifactId>javafaker</artifactId>
    <version>1.0.2</version>
</dependency>



  <!-- https://mvnrepository.com/artifact/io.rest-assured/rest-assured -->
<dependency>
    <groupId>io.rest-assured</groupId>
    <artifactId>rest-assured</artifactId>
    <version>5.4.0</version>
    <scope>test</scope>
</dependency>

<!-- https://mvnrepository.com/artifact/com.jayway.jsonpath/json-path -->
<dependency>
    <groupId>com.jayway.jsonpath</groupId>
    <artifactId>json-path</artifactId>
    <version>2.9.0</version>
</dependency>

<!-- https://mvnrepository.com/artifact/org.json/json -->
<dependency>
    <groupId>org.json</groupId>
    <artifactId>json</artifactId>
    <version>20240303</version>
</dependency>

<!-- https://mvnrepository.com/artifact/com.google.code.gson/gson -->
<dependency>
    <groupId>com.google.code.gson</groupId>
    <artifactId>gson</artifactId>
    <version>2.11.0</version>
</dependency>

<!-- https://mvnrepository.com/artifact/org.testng/testng -->
<dependency>
    <groupId>org.testng</groupId>
    <artifactId>testng</artifactId>
    <version>7.10.2</version>
    <scope>test</scope>
</dependency>


<!-- https://mvnrepository.com/artifact/com.github.scribejava/scribejava-apis -->
<dependency>
    <groupId>com.github.scribejava</groupId>
    <artifactId>scribejava-apis</artifactId>
    <version>8.3.3</version>
    <scope>runtime</scope>
</dependency>


<!-- https://mvnrepository.com/artifact/io.rest-assured/json-schema-validator -->
<dependency>
    <groupId>io.rest-assured</groupId>
    <artifactId>json-schema-validator</artifactId>
    <version>5.5.0</version>
</dependency>


<!-- https://mvnrepository.com/artifact/xml-apis/xml-apis -->
<dependency>
    <groupId>xml-apis</groupId>
    <artifactId>xml-apis</artifactId>
    <version>2.0.2</version>
</dependency>



</dependencies>


create folder structure same as shown below in an image -


------------ Insert Image here --------------


and create reports and logs folders in the project like shown in the below image.

----------------Insert image here ------------


create routes

Create end point file.


Data driven test - 

To create data driven test we need to store the data in the excel sheet.

Excel sheet data
Excel utility to read the data from excel file
DataProviders to provide the data to the test cases.


Generate extent reports - 

Extent report utility
testng.xml

add below depedency for generating extent reports - 

<dependency>
    <groupId>com.aventstack</groupId>
    <artifactId>extentreports</artifactId>
    <version>5.0.9</version> <!-- Use the latest stable version available -->
</dependency>


add logs - 

 use log4j2 dependency
 
     <!-- Log4j Core Dependency -->
    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-core</artifactId>
        <version>2.20.0</version>
    </dependency>

    <!-- Log4j API Dependency -->
    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-api</artifactId>
        <version>2.20.0</version>
    </dependency>
 

and create log4j2.xml configuration file in src/test/resources


we can also create the porperties file to map the routes instead of the class. create the properties file in src/test/resources folder.

routes.properties - 

# Base URL
base.url=https://petstore.swagger.io/v2

# User module
user.create.url=https://petstore.swagger.io/v2/user
user.get.url=https://petstore.swagger.io/v2/user/{username}
user.update.url=https://petstore.swagger.io/v2/user/{username}
user.delete.url=https://petstore.swagger.io/v2/user/{username}

# Store module
# Add store module URLs here

# Pet module
# Add pet module URLs here


Accessing the properties - 

package api.endpoints;

import static io.restassured.RestAssured.given;

import java.util.ResourceBundle;

import api.payload.User;
import io.restassured.http.ContentType;
import io.restassured.response.Response;

public class UserEndPointsUsingThePropertiesFile {

	// to the urls form properties file
	public static ResourceBundle getUrl(){
		return ResourceBundle.getBundle("routes");
	}
	
	
public static Response createUser(User payload) {
			
		Response response = given()
			.contentType(ContentType.JSON)
			.accept(ContentType.JSON)
			.body(payload)
		.when()
			.post(getUrl().getString("user.create.url"));
		
		return response;
	}
	
	public static Response readUser(String username) {
		
		Response response = given()
					.pathParam("username", username)
		.when()
			.get(getUrl().getString("user.get.url"));
		
		return response;
	}
	
	
	public static Response updateUser(String username, User payload) {
		
		Response response = given()
			.contentType(ContentType.JSON)
			.accept(ContentType.JSON)
			.body(payload)
			.pathParam("username", username)
		.when()
			.put(getUrl().getString("user.update.url"));
		
		return response;
	}
	
	
	public static Response deleteUser(String username) {
		
		Response response = given()
					.pathParam("username", username)
		.when()
			.delete(getUrl().getString("user.delete.url"));
		
		return response;
	}
	
	
}

User tests using properties routes -

package api.test;

import org.testng.annotations.Test;
import org.testng.annotations.BeforeClass;
import org.testng.AssertJUnit;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import com.github.javafaker.Faker;

import api.endpoints.UserEndPointsUsingThePropertiesFile;
import api.payload.User;
import io.restassured.response.Response;

public class UserTestsUsingPropertiesFilesRoutes {

	Faker faker;
	User userPayload ;
	public Logger logger;
	
	@BeforeClass
	public void setup() {
			faker = new Faker();
			userPayload = new User();
			
			userPayload.setId(faker.idNumber().hashCode());
			userPayload.setEmail(faker.internet().emailAddress());
			userPayload.setFirstName(faker.name().firstName());
			userPayload.setLastName(faker.name().lastName());
			userPayload.setPassword(faker.internet().password(5,10));
			userPayload.setPhone(faker.phoneNumber().cellPhone());
			userPayload.setUsername(faker.name().username());
			
			logger = LogManager.getLogger(this.getClass());
			
	}
	
	
	@Test(priority = 1)
	public void testPostUser() {
		
		logger.info("=============== Creating the User =====================");
		Response response = UserEndPointsUsingThePropertiesFile.createUser(this.userPayload);
		response.then().log().all();
		
		AssertJUnit.assertEquals(response.getStatusCode(), 200);
		logger.info("=============== User is Created =====================");
		
	}
	
	@Test(priority = 2)
	public void testGetUserByName() {
		logger.info("=============== Reading user Info =====================");
		Response response = UserEndPointsUsingThePropertiesFile.readUser(this.userPayload.getUsername());
		response.then().log().all();
		
		AssertJUnit.assertEquals(response.getStatusCode(), 200);
		logger.info("=============== user info reading completed =====================");
		
	}
	
	@Test(priority = 3)
	public void testUpdateUser() {
		
		userPayload.setFirstName("Vimal");
		userPayload.setLastName("Verma");
		userPayload.setPhone("123456789");
		
		logger.info("=============== updating the User =====================");
		
		Response response = UserEndPointsUsingThePropertiesFile.updateUser(this.userPayload.getUsername(), userPayload);
		response.then().log().all();
		
		AssertJUnit.assertEquals(response.getStatusCode(), 200);
		
		 response = UserEndPointsUsingThePropertiesFile.readUser(this.userPayload.getUsername());
		response.then().log().all();
		
		AssertJUnit.assertEquals(response.getStatusCode(), 200);
		
		logger.info("=============== User info updated =====================");
		
	}
	
	@Test(priority = 4)
	public void testDeleteUserByName() {
		
		logger.info("=============== Deleting the user =====================");
		
		Response response = UserEndPointsUsingThePropertiesFile.deleteUser(this.userPayload.getUsername());
		response.then().log().all();
		
		AssertJUnit.assertEquals(response.getStatusCode(), 200);
	
		logger.info("=============== User Deleted =====================");
		
	}
}


To invoke the test cases remotely we need to do some configuration in pom.xml - 


add below plugins in the pom.xml file - 


  <build>
    <plugins>
        <!-- Maven Surefire Plugin for running tests -->
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-surefire-plugin</artifactId>
            <version>3.0.0-M8</version>
            
        </plugin>

        <!-- Maven Compiler Plugin for setting Java version -->
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.8.1</version>
            <configuration>
              <suite>testng.xml</suite>
            </configuration>
        </plugin>
    </plugins>
</build>



in above I have mentioned the testng.xml file which i want to run through maven.


now right click on the maven and then select run as then select maven test, this will run the tests.







--------------------------



Rest API and Status codes -

Status code is a number associated with response associated with response from server.

It is shorted description of what happened at the server with that request. Client can know so many things about what happened to request at server side.

example - request successfully finished, rejected by server, or waiting for something.

Without this number client will be blind - do not know what happed with the request.

Response code provides acknowledgement to the client.

500- Internal server error
200 - OK

response codes groups - 
1xx - information responses
2xx - successful responses
3xx - Redirection responses
4xx - Client error responses
500 - server error responses


1xx - information responses - It is interim response - It comes from the server before finishing request, after this we will get one more final response from the server.

100 - continue - Respose code shows that everything is ok so far in request. client needs to enable - by putting Expect:100-Continue in intial request, after clients request, server will validate all the pre requisite to handle that request and server will tell client to continue this request by sending 100 continue otherwise 417 Expectation failed.

in this first client will request with header Expect:100 continue then server will respond with 100 to continue or 417 to not continue then if client has received the response with 100 then client will send the request body with all the information in the header then server will process that request further.

this is like asking to the server whether to continue sending or not.  

This is also used in case to save the network bandwidth, if request is too big and server can decide by just getting header from the client and decide.


101 switching protocols - it is to notify that server is switching protocols. In header client can pass Upgrade:websocket property to ask for specific protocol. If server agrees to switch, it sends 101.



Browser based games, requirement is to send data back and forth, http requires headers, cookies and lot of stuff, creating huge latency. so for this solution is to not send the headers, cookies all time, and server can also push  data if needed. websocket keeps connection open, so there is no need to send the headers each time while sending the data. In this server also can push the data. this is used for two way communication or bidirectional communication.


102 - processing - server received request and it is processing request. No any response availabel to send, when server will take more than 20 seconds to process request then this is used to prevent timeout errors.

103 - early hints - As name suggest, meaning of this response code is to gives hints to client. server is telling client that server is preparing response, meanwhile client can start other processing or preloading of data.


2xx - succccesss codes - client gets one of these codes from server when request successfully executed at client side.

200 - ok - request is successful, and there is something in request body. in case of get or head where client receives some data from server.

in case of put and post, server have finished processing and client received response.

201 - created - normally sent with post and put request when it creates a new resource.

204 - no content - this represents that request has been successful but there is no content in the body. header will be there, so client can get additional information, if needed.

205 - reset content - this response code server sends when after successful request we need to resent  document. ex filling the form, and after submitting, taht form got reset or UI is refreshed.

206 - represents that data in response body is partial, it is not entire document. if document is huge or data is huge.

multipart files - divide entire file in multiple chunks.

Range: bnytes=200-1000

client needs to specify range in byte- which chunk client needs.


3xx - redirection response codes - 

in case of , system restructuring, maintenance work, or multiple resource found, server must redirect request to some other location.

300 - multiple choice - represents that there are multiple resource options we have for that request or for that url.

multiple versions of the same document.

301 moved permamntly & 308 permanent redirect - both represents that resources has been moved to some other location permanently. location header have URL to new location.  but in case of 301 - client not allowed to change the http method, client must use same method as in first time request and in case of 308 client allowed to change http method.

302 found and 307 temporary redirect  - Both 302 and 307 represents that resource has been moed to some other location temporary.

Locatoin header have url to new location. 

302 - client not allowed to change http method, client must use same method as in first time request.

307 - client allowed to change the http method.

304 - not modified - when client request data with if-Match or If-None-Match header property. Server validate whether resource has been modified since last time. if not modified - return 304 headers with empty body, client already have latest data.

4xxx - client error response code - when something is wrongwith request coming from client. 

400 bad request - server could not understand the request because of invalid syntax, or something is not right with request. 

401 - unauthorized - client must authenticate itself by providing valid authentication credentials before executing request. there are many different types of authentication appraoches.

403 - forbidden - server knows client and eeven id authentication is correct, server is rejecting the client request because that client does not have access to that resource.

404 - not found - url is incorrect or resource does not exist. 
this is also used to hide the sensitive information or resource for security reasons.

405 - method not allowed  - http method is not allowed for provided url. 

get method should be allowed to all the resources.


406 - not acceptable - with accept header property, client can negotiate data format. this is thrown when server does not support the format of the resource requested by the client.

409 - conflict - if multiple client tries to update same resource.

Server error ocode - 

500 - internal server error - an exception which is not handled  or unfamilier to system.

503 - service unavailable - server responds this when server is not ready to accept request. could be due to overload or server is down.

504 - gateway time out - server which is acting as gateway or proxy, did not get response from other server in time.

resource of above video - https://www.youtube.com/watch?v=Gi_TSYEWN8Y


-------------------------------------

Selenium - it is open source tool which is used to for automating the tests carried out on web browsers.

why selenium -

easy to automate testing across web applications.
 
easy to implement the test cases.
supports various os. 
Easy to learn.

Features of selenium - 

cloud based.
test scripts are written in java, python, ruby.
supports parallel execution.
requires fewer resources.
No server installation required.

Components of selenium - 
Selenium IDE - used for writing the test cases.

Selenium WebDriver - this is the first cross platform testing framework that could control the browser from the OS level.

Selenium remote control - using this we can perform cross browser testing. this needs server. 
Selenium grid. - this is used in combination of RC to run test cases remotely. we can execute multiple test grids at the same time on different machines, parallel execution can be achieved, 

----------------------------------------

Postman - 


local variables - Local variables are created at the request level and it is created in the script or test tab. and they are accessible only within the current request.

data variables - these are used to get the data from the external file or api.



variables are created in the pre script and delelted in the test or post script tabs. this is done by using the scripts.


